(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.g1 = global.g1 || {}));
}(this, function (exports) { 'use strict';

  var version = "0.17.3";

  function namespace(search, name) {
    // Return an object with all keys in search that begin with `<name>:` or
    // do not have a `:` in them.
    // If name is false-y, return search
    if (!name) return search;
    var result = {};
    for (var key in search) {
      var parts = key.split(':');
      if (parts.length == 1) result[parts[0]] = search[key];else if (parts[0] === name) result[parts[1]] = search[key];
    }
    return result;
  }

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  // state_transition[old_state][current_type] -> new_state
  // type: undefined and type: null are mapped to state 'null', i.e. missing values
  var state_transitions = {
    'null': {
      'null': { state: 'null' },
      'date': { state: 'date' },
      'number': { state: 'number' },
      'boolean': { state: 'boolean' },
      'string': { state: 'string' },
      'object': { state: 'object' },
      'mixed': { state: 'mixed', end: true }
    },
    'date': {
      'null': { state: 'date' },
      'undefined': { state: 'date' },
      'date': { state: 'date' },
      'default': { state: 'mixed', end: true }
    },
    'number': {
      'null': { state: 'number' },
      'undefined': { state: 'number' },
      'number': { state: 'number' },
      'default': { state: 'mixed', end: true }
    },
    'boolean': {
      'null': { state: 'boolean' },
      'undefined': { state: 'boolean' },
      'boolean': { state: 'boolean' },
      'default': { state: 'mixed', end: true }
    },
    'string': {
      'null': { state: 'string' },
      'undefined': { state: 'string' },
      'string': { state: 'string' },
      'default': { state: 'mixed', end: true }
    },
    'object': {
      'null': { state: 'object' },
      'object': { state: 'object' },
      'undefined': { state: 'object' },
      'default': { state: 'mixed', end: true }
    },
    'mixed': {
      'default': { state: 'mixed', end: true }
    }
  };

  function types(data, options) {
    var result = {};
    if (!data || !data.length) return result;

    options = options || {};
    options.convert = options.convert || false;
    options.limit = options.limit || 1000;
    var limit = options.limit < data.length ? options.limit : data.length;
    var ignore = options.ignore = options.ignore || [null, undefined];
    var columns = Object.keys(data[0]);

    for (var columnIndex = 0; columnIndex < columns.length; columnIndex++) {
      var column = columns[columnIndex];
      var result_type = 'null';
      for (var index = 0; index < limit; index++) {
        var row = data[index];
        var value = row[column];

        if (columnIndex == 0) {
          Object.keys(data[index]).forEach(function (value) {
            if (columns.indexOf(value) == -1) columns.push(value);
          });
        }

        // Ignore if the value is missing
        if (!(column in row)) continue;
        // Ignore values that are in the ignore list
        if (ignore.indexOf(value) >= 0) continue;
        // Identify type (date, object, number, boolean, string, undefined, null)
        var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
        if (value === undefined || value === null) type = 'null';else if (type == 'object' && !isNaN(Date.parse(value))) type = 'date';else if (options.convert) {
          // We use parseFloat AND isFinite because
          // parseFloat('2018-01') is 2018 but isFinite('2018-01') is false
          // Also, 'NaN', 'Infinity' and '-Infinity' should be treated as numbers
          if (!isNaN(parseFloat(value)) && isFinite(value) || ['NaN', 'Infinity', '-Infinity'].indexOf(value) >= 0) type = 'number';else if (!isNaN(Date.parse(value))) type = 'date';else if (['true', 'false'].indexOf(value) != -1) type = 'boolean';
        }

        // Apply the state change
        var state_transition = state_transitions[type];
        var change = state_transition[result_type] || state_transition['default'];
        result_type = change['state'];
        if (change['end']) break;
      }
      result[column] = result_type;
    }
    return result;
  }

  function isEqual(value, compare_with, criteria_satisfied) {
    // to handle: ( ...Shape!&... ) or ( ...&Shape&... )
    if (!value) {
      return criteria_satisfied ? compare_with == null : compare_with != null;
    }
    return value.indexOf(compare_with) != -1 ? !criteria_satisfied : criteria_satisfied;
  }

  function greater_than(value, compare_with, include_equals) {
    if (isNaN(compare_with) && Date.parse(compare_with)) {
      compare_with = Date.parse(compare_with);
    }
    if (isNaN(value) && Date.parse(value)) {
      value = Date.parse(value);
    }
    return include_equals ? compare_with >= value : compare_with > value;
  }
  var operators = {
    '=': function _(value, compare_with) {
      return isEqual(value, compare_with, false);
    },
    '!': function _(value, compare_with) {
      return isEqual(value, compare_with, true);
    },
    '>': function _(value, compare_with) {
      return greater_than(value, compare_with, false);
    },
    '<': function _(value, compare_with) {
      return greater_than(compare_with, value, false);
    },
    '>~': function _(value, compare_with) {
      return greater_than(value, compare_with, true);
    },
    '<~': function _(value, compare_with) {
      return greater_than(compare_with, value, true);
    },
    '~': function _(value, compare_with) {
      return isEqual(compare_with, value[0], false);
    },
    '!~': function _(value, compare_with) {
      return isEqual(compare_with, value[0], true);
    }
  };

  var sorting = {
    'string': function string(value, compare_with, order) {
      if (!order) order = 'asc';
      // swap if 'desc'
      if (order == 'desc') value = [compare_with, compare_with = value][0];

      return value.localeCompare(compare_with);
    },
    'number': function number(value, compare_with, order) {
      if (!order) order = 'asc';
      // swap if 'desc'
      if (order == 'desc') value = [compare_with, compare_with = value][0];

      return value - compare_with;
    }
  };

  function clone_pluck(source, include_keys, exclude_keys) {
    if (include_keys.length == 0) include_keys = Object.keys(source);
    var new_obj = {};
    include_keys.forEach(function (key) {
      if (exclude_keys.indexOf(key) < 0) new_obj[key] = source[key];
    });
    return new_obj;
  }

  function datafilter(data, filters, dataset_name) {
    filters = filters || [];

    var result = data;
    var operator, value;

    // url namespace sanitize
    filters = namespace(filters, dataset_name);

    var data_types = types(data, { convert: true });

    // apply WHERE clause
    for (var key in filters) {
      if (key[0] == '_') continue;
      var operator_index = key.match(/(!|>|>~|<|<~|~|!~)$/) ? key.match(/(!|>|>~|<|<~|~|!~)$/).index : key.length;
      operator = key.slice(operator_index) != '' ? key.slice(operator_index) : '=';
      value = filters[key][0] != "" ? filters[key] : null;

      var col = key.slice(0, operator_index);
      if (data_types[col] == 'number') {
        value = value.map(function (val) {
          return parseFloat(val);
        });
      } else if (data_types[col] == 'boolean') {
        value = value.map(function (val) {
          return String(val) == 'true' ? true : false;
        });
      } else if (data_types[col] == 'date') {
        value = value.map(function (val) {
          return Date.parse(val);
        });
      }

      result = result.filter(function (row) {
        return typeof row[col] != 'undefined' ? operators[operator](value, row[col]) : true;
      });
    }

    var offset = parseInt(filters['_offset']) || 0;
    var limit = parseInt(filters['_limit']) || 1000;

    result = result.slice(offset, offset + limit);

    // apply SELECT clause
    if (filters['_c']) {
      var exclude_cols = [],
          include_cols = [];
      filters['_c'].forEach(function (column) {
        column[0] == '-' ? exclude_cols.push(column.slice(1)) : include_cols.push(column);
      });
      result = result.map(function (row) {
        return clone_pluck(row, include_cols, exclude_cols);
      });
    }

    if (filters['_sort']) {
      result.sort(function (a, b) {
        var swap_rows = false;
        filters['_sort'].forEach(function (sort) {
          var order = sort[0] == '-' ? 'desc' : 'asc';
          if (sort[0] == '-') sort = sort.substr(1);
          if (typeof a[sort] == 'undefined') return;
          // if sort.column evaluates to false, it will proceed with evaluating || expression
          var type = isNaN(a[sort]) ? 'string' : 'number';
          swap_rows = swap_rows || sorting[type](a[sort], b[sort], order);
        });
        return swap_rows;
      });
    }

    return result;
  }

  /*
    var search = g1.fuzzysearch(data, options)
    // Specify keys in data as a list of column names or functions
    options.keys = [ 'col1', function(v) { return v.info.name } ]
    // Specify max results to return. Default: 100
    options.limit = 10
    // Case sensitive search. Default: false
    options.case = True
  */
  function fuzzysearch(data, options) {
    options = options || {};
    // "values" is the string array with the text to search
    var values;
    // If no options.keys are provided, use the raw data as-is
    if (!options.keys) values = data;
    // Else, join the provided keys
    else values = data.map(function (row) {
        return options.keys.map(function (v) {
          return typeof v == 'function' ? v(row) : row[v];
        }).join(' ');
      });
    var limit = options.limit || 100;
    var flags = options.case ? '' : 'i';
    // TODO: document these options once stabilized
    var depth = options.depth || 10;
    var escape = options.escape || true;

    return function (text) {
      var results = [],
          // Final results
      vals = values.slice(),
          // Values to search. Crosses off matches to avoid duplication
      re;
      // Trim the search text
      text = text.replace(/^\s/, '').replace(/\s$/, '');
      if (escape) text = text.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');

      // 1. Match full phrase
      re = new RegExp(text.replace(/\s+/, '\\s+'), flags);
      vals.forEach(function (v, i) {
        if (v && re.test(v)) {
          results.push(data[i]);vals[i] = '';
        }
      });
      if (depth <= 1 || results.length >= limit) return results.slice(0, limit);

      // 2. Match words in order
      re = new RegExp(text.replace(/\s+/, '.*'), flags);
      vals.forEach(function (v, i) {
        if (v && re.test(v)) {
          results.push(data[i]);vals[i] = '';
        }
      });
      if (depth <= 2 || results.length >= limit) return results.slice(0, limit);

      // 3. Match words in any order
      re = text.split(/\s+/).map(function (word) {
        return new RegExp(word, flags);
      });
      vals.forEach(function (v, i) {
        if (v && re.every(function (word) {
          return word.test(v);
        })) {
          results.push(data[i]);vals[i] = '';
        }
      });
      if (depth <= 3 || results.length >= limit) return results.slice(0, limit);

      // 4. Match partial words in any order
      re = text.split(/\s+/).map(function (word) {
        return new RegExp(word.replace(/(.)/g, '$&[\\S]*'), flags);
      });
      vals.forEach(function (v, i) {
        if (v && re.every(function (word) {
          return word.test(v);
        })) {
          results.push(data[i]);vals[i] = '';
        }
      });

      // 5. Match characters in order
      re = new RegExp(text.replace(/(.)/g, '$&.*'), flags);
      vals.forEach(function (v, i) {
        if (v && re.test(v)) {
          results.push(data[i]);vals[i] = '';
        }
      });
      if (depth <= 4 || results.length >= limit) return results.slice(0, limit);

      return results.slice(0, limit);
    };
  }

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Built-in value references. */
  var _Symbol = root.Symbol;

  /** Used for built-in method references. */
  var objectProto = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto.toString;

  /** Built-in value references. */
  var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag),
        tag = value[symToStringTag];

    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }

  /** Used for built-in method references. */
  var objectProto$1 = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$1 = objectProto$1.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString(value) {
    return nativeObjectToString$1.call(value);
  }

  /** `Object#toString` result references. */
  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';

  /** Built-in value references. */
  var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag$1 && symToStringTag$1 in Object(value) ? getRawTag(value) : objectToString(value);
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
    return value != null && (type == 'object' || type == 'function');
  }

  /** `Object#toString` result references. */
  var asyncTag = '[object AsyncFunction]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      proxyTag = '[object Proxy]';

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  /** Used to detect overreaching core-js shims. */
  var coreJsData = root['__core-js_shared__'];

  /** Used to detect methods masquerading as native. */
  var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
  }();

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }

  /** Used for built-in method references. */
  var funcProto = Function.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}
      try {
        return func + '';
      } catch (e) {}
    }
    return '';
  }

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used for built-in method references. */
  var funcProto$1 = Function.prototype,
      objectProto$2 = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$1 = funcProto$1.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

  /** Used to detect if a method is native. */
  var reIsNative = RegExp('^' + funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }

  /* Built-in method references that are verified to be native. */
  var nativeCreate = getNative(Object, 'create');

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used for built-in method references. */
  var objectProto$3 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty$2.call(data, key) ? data[key] : undefined;
  }

  /** Used for built-in method references. */
  var objectProto$4 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty$3.call(data, key);
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED$1 : value;
    return this;
  }

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `Hash`.
  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }

  /** Used for built-in method references. */
  var arrayProto = Array.prototype;

  /** Built-in value references. */
  var splice = arrayProto.splice;

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    return index < 0 ? undefined : data[index][1];
  }

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet(key, value) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `ListCache`.
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;

  /* Built-in method references that are verified to be native. */
  var Map = getNative(root, 'Map');

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new Hash(),
      'map': new (Map || ListCache)(),
      'string': new Hash()
    };
  }

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable(value) {
    var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
  }

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
  }

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete(key) {
    var result = getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet(key, value) {
    var data = getMapData(this, key),
        size = data.size;

    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `MapCache`.
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

  /**
   * Adds `value` to the array cache.
   *
   * @private
   * @name add
   * @memberOf SetCache
   * @alias push
   * @param {*} value The value to cache.
   * @returns {Object} Returns the cache instance.
   */
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED$2);
    return this;
  }

  /**
   * Checks if `value` is in the array cache.
   *
   * @private
   * @name has
   * @memberOf SetCache
   * @param {*} value The value to search for.
   * @returns {number} Returns `true` if `value` is found, else `false`.
   */
  function setCacheHas(value) {
    return this.__data__.has(value);
  }

  /**
   *
   * Creates an array cache object to store unique values.
   *
   * @private
   * @constructor
   * @param {Array} [values] The values to cache.
   */
  function SetCache(values) {
    var index = -1,
        length = values == null ? 0 : values.length;

    this.__data__ = new MapCache();
    while (++index < length) {
      this.add(values[index]);
    }
  }

  // Add methods to `SetCache`.
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN(value) {
    return value !== value;
  }

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
  }

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  /* Built-in method references that are verified to be native. */
  var Set = getNative(root, 'Set');

  /**
   * This method returns `undefined`.
   *
   * @static
   * @memberOf _
   * @since 2.3.0
   * @category Util
   * @example
   *
   * _.times(2, _.noop);
   * // => [undefined, undefined]
   */
  function noop() {
    // No operation performed.
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function (value) {
      result[++index] = value;
    });
    return result;
  }

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0;

  /**
   * Creates a set object of `values`.
   *
   * @private
   * @param {Array} values The values to add to the set.
   * @returns {Object} Returns the new set.
   */
  var createSet = !(Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY) ? noop : function (values) {
    return new Set(values);
  };

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /**
   * The base implementation of `_.uniqBy` without support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} [iteratee] The iteratee invoked per element.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns the new duplicate free array.
   */
  function baseUniq(array, iteratee, comparator) {
    var index = -1,
        includes = arrayIncludes,
        length = array.length,
        isCommon = true,
        result = [],
        seen = result;

    if (comparator) {
      isCommon = false;
      includes = arrayIncludesWith;
    } else if (length >= LARGE_ARRAY_SIZE) {
      var set = iteratee ? null : createSet(array);
      if (set) {
        return setToArray(set);
      }
      isCommon = false;
      includes = cacheHas;
      seen = new SetCache();
    } else {
      seen = iteratee ? [] : result;
    }
    outer: while (++index < length) {
      var value = array[index],
          computed = iteratee ? iteratee(value) : value;

      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed === computed) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed) {
            continue outer;
          }
        }
        if (iteratee) {
          seen.push(computed);
        }
        result.push(value);
      } else if (!includes(seen, computed, comparator)) {
        if (seen !== result) {
          seen.push(computed);
        }
        result.push(value);
      }
    }
    return result;
  }

  /**
   * Creates a duplicate-free version of an array, using
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons, in which only the first occurrence of each element
   * is kept. The order of result values is determined by the order they occur
   * in the array.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @returns {Array} Returns the new duplicate free array.
   * @example
   *
   * _.uniq([2, 1, 2]);
   * // => [2, 1]
   */
  function uniq(array) {
    return array && array.length ? baseUniq(array) : [];
  }

  /**
   * The base implementation of `_.slice` without an iteratee call guard.
   *
   * @private
   * @param {Array} array The array to slice.
   * @param {number} [start=0] The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the slice of `array`.
   */
  function baseSlice(array, start, end) {
    var index = -1,
        length = array.length;

    if (start < 0) {
      start = -start > length ? 0 : length + start;
    }
    end = end > length ? length : end;
    if (end < 0) {
      end += length;
    }
    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;

    var result = Array(length);
    while (++index < length) {
      result[index] = array[index + start];
    }
    return result;
  }

  /**
   * Casts `array` to a slice if it's needed.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {number} start The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the cast slice.
   */
  function castSlice(array, start, end) {
    var length = array.length;
    end = end === undefined ? length : end;
    return !start && end >= length ? array : baseSlice(array, start, end);
  }

  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsVarRange = '\\ufe0e\\ufe0f';

  /** Used to compose unicode capture groups. */
  var rsZWJ = '\\u200d';

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + ']');

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  /** Used to compose unicode character classes. */
  var rsAstralRange$1 = '\\ud800-\\udfff',
      rsComboMarksRange$1 = '\\u0300-\\u036f',
      reComboHalfMarksRange$1 = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange$1 = '\\u20d0-\\u20ff',
      rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1,
      rsVarRange$1 = '\\ufe0e\\ufe0f';

  /** Used to compose unicode capture groups. */
  var rsAstral = '[' + rsAstralRange$1 + ']',
      rsCombo = '[' + rsComboRange$1 + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange$1 + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsZWJ$1 = '\\u200d';

  /** Used to compose unicode regexes. */
  var reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange$1 + ']?',
      rsOptJoin = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray(string) {
      return string.match(reUnicode) || [];
  }

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
  }

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray = Array.isArray;

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return value != null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object';
  }

  /** `Object#toString` result references. */
  var symbolTag = '[object Symbol]';

  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */
  function isSymbol(value) {
    return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
  }

  /** Used as references for various `Number` constants. */
  var INFINITY$1 = 1 / 0;

  /** Used to convert symbols to primitives and strings. */
  var symbolProto = _Symbol ? _Symbol.prototype : undefined,
      symbolToString = symbolProto ? symbolProto.toString : undefined;

  /**
   * The base implementation of `_.toString` which doesn't convert nullish
   * values to empty strings.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
      return value;
    }
    if (isArray(value)) {
      // Recursively convert values (susceptible to call stack limits).
      return arrayMap(value, baseToString) + '';
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY$1 ? '-0' : result;
  }

  /**
   * Converts `value` to a string. An empty string is returned for `null`
   * and `undefined` values. The sign of `-0` is preserved.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.toString(null);
   * // => ''
   *
   * _.toString(-0);
   * // => '-0'
   *
   * _.toString([1, 2, 3]);
   * // => '1,2,3'
   */
  function toString(value) {
    return value == null ? '' : baseToString(value);
  }

  /**
   * Creates a function like `_.lowerFirst`.
   *
   * @private
   * @param {string} methodName The name of the `String` case method to use.
   * @returns {Function} Returns the new case function.
   */
  function createCaseFirst(methodName) {
    return function (string) {
      string = toString(string);

      var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined;

      var chr = strSymbols ? strSymbols[0] : string.charAt(0);

      var trailing = strSymbols ? castSlice(strSymbols, 1).join('') : string.slice(1);

      return chr[methodName]() + trailing;
    };
  }

  /**
   * Converts the first character of `string` to upper case.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category String
   * @param {string} [string=''] The string to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.upperFirst('fred');
   * // => 'Fred'
   *
   * _.upperFirst('FRED');
   * // => 'FRED'
   */
  var upperFirst = createCaseFirst('toUpperCase');

  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */
  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function stackDelete(key) {
    var data = this.__data__,
        result = data['delete'](key);

    this.size = data.size;
    return result;
  }

  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function stackGet(key) {
    return this.__data__.get(key);
  }

  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function stackHas(key) {
    return this.__data__.has(key);
  }

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE$1 = 200;

  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs = data.__data__;
      if (!Map || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }

  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }

  // Add methods to `Stack`.
  Stack.prototype.clear = stackClear;
  Stack.prototype['delete'] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  var defineProperty = function () {
    try {
      var func = getNative(Object, 'defineProperty');
      func({}, '', {});
      return func;
    } catch (e) {}
  }();

  /**
   * The base implementation of `assignValue` and `assignMergeValue` without
   * value checks.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function baseAssignValue(object, key, value) {
    if (key == '__proto__' && defineProperty) {
      defineProperty(object, key, {
        'configurable': true,
        'enumerable': true,
        'value': value,
        'writable': true
      });
    } else {
      object[key] = value;
    }
  }

  /** Used for built-in method references. */
  var objectProto$5 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

  /**
   * Assigns `value` to `key` of `object` if the existing value is not equivalent
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty$4.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  }

  /**
   * Copies properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy properties from.
   * @param {Array} props The property identifiers to copy.
   * @param {Object} [object={}] The object to copy properties to.
   * @param {Function} [customizer] The function to customize copied values.
   * @returns {Object} Returns `object`.
   */
  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});

    var index = -1,
        length = props.length;

    while (++index < length) {
      var key = props[index];

      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

      if (newValue === undefined) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue(object, key, newValue);
      }
    }
    return object;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]';

  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
  }

  /** Used for built-in method references. */
  var objectProto$6 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$5 = objectProto$6.hasOwnProperty;

  /** Built-in value references. */
  var propertyIsEnumerable = objectProto$6.propertyIsEnumerable;

  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  var isArguments = baseIsArguments(function () {
    return arguments;
  }()) ? baseIsArguments : function (value) {
    return isObjectLike(value) && hasOwnProperty$5.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
  };

  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */
  function stubFalse() {
    return false;
  }

  /** Detect free variable `exports`. */
  var freeExports = (typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && (typeof module === 'undefined' ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Built-in value references. */
  var Buffer = moduleExports ? root.Buffer : undefined;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */
  var isBuffer = nativeIsBuffer || stubFalse;

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER = 9007199254740991;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex(value, length) {
    var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
    length = length == null ? MAX_SAFE_INTEGER : length;

    return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
  }

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER$1 = 9007199254740991;

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */
  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
  }

  /** `Object#toString` result references. */
  var argsTag$1 = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag$1 = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */
  function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function (value) {
      return func(value);
    };
  }

  /** Detect free variable `exports`. */
  var freeExports$1 = (typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule$1 = freeExports$1 && (typeof module === 'undefined' ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports$1 && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = function () {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }();

  /* Node.js helper references. */
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

  /** Used for built-in method references. */
  var objectProto$7 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$6 = objectProto$7.hasOwnProperty;

  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value),
        isArg = !isArr && isArguments(value),
        isBuff = !isArr && !isArg && isBuffer(value),
        isType = !isArr && !isArg && !isBuff && isTypedArray(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? baseTimes(value.length, String) : [],
        length = result.length;

    for (var key in value) {
      if ((inherited || hasOwnProperty$6.call(value, key)) && !(skipIndexes && (
      // Safari 9 has enumerable `arguments.length` in strict mode.
      key == 'length' ||
      // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key == 'offset' || key == 'parent') ||
      // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||
      // Skip index properties.
      isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }

  /** Used for built-in method references. */
  var objectProto$8 = Object.prototype;

  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */
  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$8;

    return value === proto;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeKeys = overArg(Object.keys, Object);

  /** Used for built-in method references. */
  var objectProto$9 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$7 = objectProto$9.hasOwnProperty;

  /**
   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty$7.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }

  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }

  /**
   * The base implementation of `_.assign` without support for multiple sources
   * or `customizer` functions.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @returns {Object} Returns `object`.
   */
  function baseAssign(object, source) {
    return object && copyObject(source, keys(source), object);
  }

  /**
   * This function is like
   * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * except that it includes inherited enumerable properties.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }

  /** Used for built-in method references. */
  var objectProto$a = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$8 = objectProto$a.hasOwnProperty;

  /**
   * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeysIn(object) {
    if (!isObject(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object),
        result = [];

    for (var key in object) {
      if (!(key == 'constructor' && (isProto || !hasOwnProperty$8.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Creates an array of the own and inherited enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keysIn(new Foo);
   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
   */
  function keysIn$1(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }

  /**
   * The base implementation of `_.assignIn` without support for multiple sources
   * or `customizer` functions.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @returns {Object} Returns `object`.
   */
  function baseAssignIn(object, source) {
    return object && copyObject(source, keysIn$1(source), object);
  }

  /** Detect free variable `exports`. */
  var freeExports$2 = (typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule$2 = freeExports$2 && (typeof module === 'undefined' ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;

  /** Built-in value references. */
  var Buffer$1 = moduleExports$2 ? root.Buffer : undefined,
      allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : undefined;

  /**
   * Creates a clone of  `buffer`.
   *
   * @private
   * @param {Buffer} buffer The buffer to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Buffer} Returns the cloned buffer.
   */
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length,
        result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

    buffer.copy(result);
    return result;
  }

  /**
   * Copies the values of `source` to `array`.
   *
   * @private
   * @param {Array} source The array to copy values from.
   * @param {Array} [array=[]] The array to copy values to.
   * @returns {Array} Returns `array`.
   */
  function copyArray(source, array) {
    var index = -1,
        length = source.length;

    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * This method returns a new empty array.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {Array} Returns the new empty array.
   * @example
   *
   * var arrays = _.times(2, _.stubArray);
   *
   * console.log(arrays);
   * // => [[], []]
   *
   * console.log(arrays[0] === arrays[1]);
   * // => false
   */
  function stubArray() {
    return [];
  }

  /** Used for built-in method references. */
  var objectProto$b = Object.prototype;

  /** Built-in value references. */
  var propertyIsEnumerable$1 = objectProto$b.propertyIsEnumerable;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeGetSymbols = Object.getOwnPropertySymbols;

  /**
   * Creates an array of the own enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */
  var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function (symbol) {
      return propertyIsEnumerable$1.call(object, symbol);
    });
  };

  /**
   * Copies own symbols of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy symbols from.
   * @param {Object} [object={}] The object to copy symbols to.
   * @returns {Object} Returns `object`.
   */
  function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /** Built-in value references. */
  var getPrototype = overArg(Object.getPrototypeOf, Object);

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

  /**
   * Creates an array of the own and inherited enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */
  var getSymbolsIn = !nativeGetSymbols$1 ? stubArray : function (object) {
    var result = [];
    while (object) {
      arrayPush(result, getSymbols(object));
      object = getPrototype(object);
    }
    return result;
  };

  /**
   * Copies own and inherited symbols of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy symbols from.
   * @param {Object} [object={}] The object to copy symbols to.
   * @returns {Object} Returns `object`.
   */
  function copySymbolsIn(source, object) {
    return copyObject(source, getSymbolsIn(source), object);
  }

  /**
   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
   * `keysFunc` and `symbolsFunc` to get the enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @param {Function} symbolsFunc The function to get the symbols of `object`.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
  }

  /**
   * Creates an array of own enumerable property names and symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }

  /**
   * Creates an array of own and inherited enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function getAllKeysIn(object) {
    return baseGetAllKeys(object, keysIn$1, getSymbolsIn);
  }

  /* Built-in method references that are verified to be native. */
  var DataView = getNative(root, 'DataView');

  /* Built-in method references that are verified to be native. */
  var Promise$1 = getNative(root, 'Promise');

  /* Built-in method references that are verified to be native. */
  var WeakMap = getNative(root, 'WeakMap');

  /** `Object#toString` result references. */
  var mapTag$1 = '[object Map]',
      objectTag$1 = '[object Object]',
      promiseTag = '[object Promise]',
      setTag$1 = '[object Set]',
      weakMapTag$1 = '[object WeakMap]';

  var dataViewTag$1 = '[object DataView]';

  /** Used to detect maps, sets, and weakmaps. */
  var dataViewCtorString = toSource(DataView),
      mapCtorString = toSource(Map),
      promiseCtorString = toSource(Promise$1),
      setCtorString = toSource(Set),
      weakMapCtorString = toSource(WeakMap);

  /**
   * Gets the `toStringTag` of `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  var getTag = baseGetTag;

  // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
  if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$1 || Map && getTag(new Map()) != mapTag$1 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set && getTag(new Set()) != setTag$1 || WeakMap && getTag(new WeakMap()) != weakMapTag$1) {
      getTag = function getTag(value) {
          var result = baseGetTag(value),
              Ctor = result == objectTag$1 ? value.constructor : undefined,
              ctorString = Ctor ? toSource(Ctor) : '';

          if (ctorString) {
              switch (ctorString) {
                  case dataViewCtorString:
                      return dataViewTag$1;
                  case mapCtorString:
                      return mapTag$1;
                  case promiseCtorString:
                      return promiseTag;
                  case setCtorString:
                      return setTag$1;
                  case weakMapCtorString:
                      return weakMapTag$1;
              }
          }
          return result;
      };
  }

  var getTag$1 = getTag;

  /** Used for built-in method references. */
  var objectProto$c = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$9 = objectProto$c.hasOwnProperty;

  /**
   * Initializes an array clone.
   *
   * @private
   * @param {Array} array The array to clone.
   * @returns {Array} Returns the initialized clone.
   */
  function initCloneArray(array) {
    var length = array.length,
        result = new array.constructor(length);

    // Add properties assigned by `RegExp#exec`.
    if (length && typeof array[0] == 'string' && hasOwnProperty$9.call(array, 'index')) {
      result.index = array.index;
      result.input = array.input;
    }
    return result;
  }

  /** Built-in value references. */
  var Uint8Array = root.Uint8Array;

  /**
   * Creates a clone of `arrayBuffer`.
   *
   * @private
   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
   * @returns {ArrayBuffer} Returns the cloned array buffer.
   */
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
    return result;
  }

  /**
   * Creates a clone of `dataView`.
   *
   * @private
   * @param {Object} dataView The data view to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned data view.
   */
  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /**
   * Creates a clone of `regexp`.
   *
   * @private
   * @param {Object} regexp The regexp to clone.
   * @returns {Object} Returns the cloned regexp.
   */
  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }

  /** Used to convert symbols to primitives and strings. */
  var symbolProto$1 = _Symbol ? _Symbol.prototype : undefined,
      symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : undefined;

  /**
   * Creates a clone of the `symbol` object.
   *
   * @private
   * @param {Object} symbol The symbol object to clone.
   * @returns {Object} Returns the cloned symbol object.
   */
  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }

  /**
   * Creates a clone of `typedArray`.
   *
   * @private
   * @param {Object} typedArray The typed array to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned typed array.
   */
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }

  /** `Object#toString` result references. */
  var boolTag$1 = '[object Boolean]',
      dateTag$1 = '[object Date]',
      mapTag$2 = '[object Map]',
      numberTag$1 = '[object Number]',
      regexpTag$1 = '[object RegExp]',
      setTag$2 = '[object Set]',
      stringTag$1 = '[object String]',
      symbolTag$1 = '[object Symbol]';

  var arrayBufferTag$1 = '[object ArrayBuffer]',
      dataViewTag$2 = '[object DataView]',
      float32Tag$1 = '[object Float32Array]',
      float64Tag$1 = '[object Float64Array]',
      int8Tag$1 = '[object Int8Array]',
      int16Tag$1 = '[object Int16Array]',
      int32Tag$1 = '[object Int32Array]',
      uint8Tag$1 = '[object Uint8Array]',
      uint8ClampedTag$1 = '[object Uint8ClampedArray]',
      uint16Tag$1 = '[object Uint16Array]',
      uint32Tag$1 = '[object Uint32Array]';

  /**
   * Initializes an object clone based on its `toStringTag`.
   *
   * **Note:** This function only supports cloning values with tags of
   * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
   *
   * @private
   * @param {Object} object The object to clone.
   * @param {string} tag The `toStringTag` of the object to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the initialized clone.
   */
  function initCloneByTag(object, tag, isDeep) {
    var Ctor = object.constructor;
    switch (tag) {
      case arrayBufferTag$1:
        return cloneArrayBuffer(object);

      case boolTag$1:
      case dateTag$1:
        return new Ctor(+object);

      case dataViewTag$2:
        return cloneDataView(object, isDeep);

      case float32Tag$1:case float64Tag$1:
      case int8Tag$1:case int16Tag$1:case int32Tag$1:
      case uint8Tag$1:case uint8ClampedTag$1:case uint16Tag$1:case uint32Tag$1:
        return cloneTypedArray(object, isDeep);

      case mapTag$2:
        return new Ctor();

      case numberTag$1:
      case stringTag$1:
        return new Ctor(object);

      case regexpTag$1:
        return cloneRegExp(object);

      case setTag$2:
        return new Ctor();

      case symbolTag$1:
        return cloneSymbol(object);
    }
  }

  /** Built-in value references. */
  var objectCreate = Object.create;

  /**
   * The base implementation of `_.create` without support for assigning
   * properties to the created object.
   *
   * @private
   * @param {Object} proto The object to inherit from.
   * @returns {Object} Returns the new object.
   */
  var baseCreate = function () {
    function object() {}
    return function (proto) {
      if (!isObject(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object();
      object.prototype = undefined;
      return result;
    };
  }();

  /**
   * Initializes an object clone.
   *
   * @private
   * @param {Object} object The object to clone.
   * @returns {Object} Returns the initialized clone.
   */
  function initCloneObject(object) {
    return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
  }

  /** `Object#toString` result references. */
  var mapTag$3 = '[object Map]';

  /**
   * The base implementation of `_.isMap` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a map, else `false`.
   */
  function baseIsMap(value) {
    return isObjectLike(value) && getTag$1(value) == mapTag$3;
  }

  /* Node.js helper references. */
  var nodeIsMap = nodeUtil && nodeUtil.isMap;

  /**
   * Checks if `value` is classified as a `Map` object.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a map, else `false`.
   * @example
   *
   * _.isMap(new Map);
   * // => true
   *
   * _.isMap(new WeakMap);
   * // => false
   */
  var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

  /** `Object#toString` result references. */
  var setTag$3 = '[object Set]';

  /**
   * The base implementation of `_.isSet` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a set, else `false`.
   */
  function baseIsSet(value) {
    return isObjectLike(value) && getTag$1(value) == setTag$3;
  }

  /* Node.js helper references. */
  var nodeIsSet = nodeUtil && nodeUtil.isSet;

  /**
   * Checks if `value` is classified as a `Set` object.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a set, else `false`.
   * @example
   *
   * _.isSet(new Set);
   * // => true
   *
   * _.isSet(new WeakSet);
   * // => false
   */
  var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;

  /** `Object#toString` result references. */
  var argsTag$2 = '[object Arguments]',
      arrayTag$1 = '[object Array]',
      boolTag$2 = '[object Boolean]',
      dateTag$2 = '[object Date]',
      errorTag$1 = '[object Error]',
      funcTag$2 = '[object Function]',
      genTag$1 = '[object GeneratorFunction]',
      mapTag$4 = '[object Map]',
      numberTag$2 = '[object Number]',
      objectTag$2 = '[object Object]',
      regexpTag$2 = '[object RegExp]',
      setTag$4 = '[object Set]',
      stringTag$2 = '[object String]',
      symbolTag$2 = '[object Symbol]',
      weakMapTag$2 = '[object WeakMap]';

  var arrayBufferTag$2 = '[object ArrayBuffer]',
      dataViewTag$3 = '[object DataView]',
      float32Tag$2 = '[object Float32Array]',
      float64Tag$2 = '[object Float64Array]',
      int8Tag$2 = '[object Int8Array]',
      int16Tag$2 = '[object Int16Array]',
      int32Tag$2 = '[object Int32Array]',
      uint8Tag$2 = '[object Uint8Array]',
      uint8ClampedTag$2 = '[object Uint8ClampedArray]',
      uint16Tag$2 = '[object Uint16Array]',
      uint32Tag$2 = '[object Uint32Array]';

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag$2] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$2] = cloneableTags[dataViewTag$3] = cloneableTags[boolTag$2] = cloneableTags[dateTag$2] = cloneableTags[float32Tag$2] = cloneableTags[float64Tag$2] = cloneableTags[int8Tag$2] = cloneableTags[int16Tag$2] = cloneableTags[int32Tag$2] = cloneableTags[mapTag$4] = cloneableTags[numberTag$2] = cloneableTags[objectTag$2] = cloneableTags[regexpTag$2] = cloneableTags[setTag$4] = cloneableTags[stringTag$2] = cloneableTags[symbolTag$2] = cloneableTags[uint8Tag$2] = cloneableTags[uint8ClampedTag$2] = cloneableTags[uint16Tag$2] = cloneableTags[uint32Tag$2] = true;
  cloneableTags[errorTag$1] = cloneableTags[funcTag$2] = cloneableTags[weakMapTag$2] = false;

  /**
   * The base implementation of `_.clone` and `_.cloneDeep` which tracks
   * traversed objects.
   *
   * @private
   * @param {*} value The value to clone.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Deep clone
   *  2 - Flatten inherited properties
   *  4 - Clone symbols
   * @param {Function} [customizer] The function to customize cloning.
   * @param {string} [key] The key of `value`.
   * @param {Object} [object] The parent object of `value`.
   * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
   * @returns {*} Returns the cloned value.
   */
  function baseClone(value, bitmask, customizer, key, object, stack) {
    var result,
        isDeep = bitmask & CLONE_DEEP_FLAG,
        isFlat = bitmask & CLONE_FLAT_FLAG,
        isFull = bitmask & CLONE_SYMBOLS_FLAG;

    if (customizer) {
      result = object ? customizer(value, key, object, stack) : customizer(value);
    }
    if (result !== undefined) {
      return result;
    }
    if (!isObject(value)) {
      return value;
    }
    var isArr = isArray(value);
    if (isArr) {
      result = initCloneArray(value);
      if (!isDeep) {
        return copyArray(value, result);
      }
    } else {
      var tag = getTag$1(value),
          isFunc = tag == funcTag$2 || tag == genTag$1;

      if (isBuffer(value)) {
        return cloneBuffer(value, isDeep);
      }
      if (tag == objectTag$2 || tag == argsTag$2 || isFunc && !object) {
        result = isFlat || isFunc ? {} : initCloneObject(value);
        if (!isDeep) {
          return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }
        result = initCloneByTag(value, tag, isDeep);
      }
    }
    // Check for circular references and return its corresponding clone.
    stack || (stack = new Stack());
    var stacked = stack.get(value);
    if (stacked) {
      return stacked;
    }
    stack.set(value, result);

    if (isSet(value)) {
      value.forEach(function (subValue) {
        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
      });
    } else if (isMap(value)) {
      value.forEach(function (subValue, key) {
        result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
    }

    var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;

    var props = isArr ? undefined : keysFunc(value);
    arrayEach(props || value, function (subValue, key) {
      if (props) {
        key = subValue;
        subValue = value[key];
      }
      // Recursively populate clone (susceptible to call stack limits).
      assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
    return result;
  }

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /**
   * A specialized version of `baseIsEqualDeep` for arrays with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Array} array The array to compare.
   * @param {Array} other The other array to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `array` and `other` objects.
   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
   */
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
        arrLength = array.length,
        othLength = other.length;

    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    // Assume cyclic values are equal.
    var stacked = stack.get(array);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var index = -1,
        result = true,
        seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;

    stack.set(array, other);
    stack.set(other, array);

    // Ignore non-index properties.
    while (++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index];

      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
      }
      if (compared !== undefined) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      // Recursively compare arrays (susceptible to call stack limits).
      if (seen) {
        if (!arraySome(other, function (othValue, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }
    stack['delete'](array);
    stack['delete'](other);
    return result;
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function (value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$1 = 1,
      COMPARE_UNORDERED_FLAG$1 = 2;

  /** `Object#toString` result references. */
  var boolTag$3 = '[object Boolean]',
      dateTag$3 = '[object Date]',
      errorTag$2 = '[object Error]',
      mapTag$5 = '[object Map]',
      numberTag$3 = '[object Number]',
      regexpTag$3 = '[object RegExp]',
      setTag$5 = '[object Set]',
      stringTag$3 = '[object String]',
      symbolTag$3 = '[object Symbol]';

  var arrayBufferTag$3 = '[object ArrayBuffer]',
      dataViewTag$4 = '[object DataView]';

  /** Used to convert symbols to primitives and strings. */
  var symbolProto$2 = _Symbol ? _Symbol.prototype : undefined,
      symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : undefined;

  /**
   * A specialized version of `baseIsEqualDeep` for comparing objects of
   * the same `toStringTag`.
   *
   * **Note:** This function only supports comparing values with tags of
   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {string} tag The `toStringTag` of the objects to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag$4:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;

      case arrayBufferTag$3:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
          return false;
        }
        return true;

      case boolTag$3:
      case dateTag$3:
      case numberTag$3:
        // Coerce booleans to `1` or `0` and dates to milliseconds.
        // Invalid dates are coerced to `NaN`.
        return eq(+object, +other);

      case errorTag$2:
        return object.name == other.name && object.message == other.message;

      case regexpTag$3:
      case stringTag$3:
        // Coerce regexes to strings and treat strings, primitives and objects,
        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
        // for more details.
        return object == other + '';

      case mapTag$5:
        var convert = mapToArray;

      case setTag$5:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
        convert || (convert = setToArray);

        if (object.size != other.size && !isPartial) {
          return false;
        }
        // Assume cyclic values are equal.
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG$1;

        // Recursively compare objects (susceptible to call stack limits).
        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack['delete'](object);
        return result;

      case symbolTag$3:
        if (symbolValueOf$1) {
          return symbolValueOf$1.call(object) == symbolValueOf$1.call(other);
        }
    }
    return false;
  }

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$2 = 1;

  /** Used for built-in method references. */
  var objectProto$d = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$a = objectProto$d.hasOwnProperty;

  /**
   * A specialized version of `baseIsEqualDeep` for objects with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,
        objProps = getAllKeys(object),
        objLength = objProps.length,
        othProps = getAllKeys(other),
        othLength = othProps.length;

    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty$a.call(other, key))) {
        return false;
      }
    }
    // Assume cyclic values are equal.
    var stacked = stack.get(object);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);

    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
          othValue = other[key];

      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      }
      // Recursively compare objects (susceptible to call stack limits).
      if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == 'constructor');
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor;

      // Non `Object` object instances with different constructors are not equal.
      if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack['delete'](object);
    stack['delete'](other);
    return result;
  }

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$3 = 1;

  /** `Object#toString` result references. */
  var argsTag$3 = '[object Arguments]',
      arrayTag$2 = '[object Array]',
      objectTag$3 = '[object Object]';

  /** Used for built-in method references. */
  var objectProto$e = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$b = objectProto$e.hasOwnProperty;

  /**
   * A specialized version of `baseIsEqual` for arrays and objects which performs
   * deep comparisons and tracks traversed objects enabling objects with circular
   * references to be compared.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} [stack] Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray(object),
        othIsArr = isArray(other),
        objTag = objIsArr ? arrayTag$2 : getTag$1(object),
        othTag = othIsArr ? arrayTag$2 : getTag$1(other);

    objTag = objTag == argsTag$3 ? objectTag$3 : objTag;
    othTag = othTag == argsTag$3 ? objectTag$3 : othTag;

    var objIsObj = objTag == objectTag$3,
        othIsObj = othTag == objectTag$3,
        isSameTag = objTag == othTag;

    if (isSameTag && isBuffer(object)) {
      if (!isBuffer(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack());
      return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
      var objIsWrapped = objIsObj && hasOwnProperty$b.call(object, '__wrapped__'),
          othIsWrapped = othIsObj && hasOwnProperty$b.call(other, '__wrapped__');

      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object,
            othUnwrapped = othIsWrapped ? other.value() : other;

        stack || (stack = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack());
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }

  /**
   * The base implementation of `_.isEqual` which supports partial comparisons
   * and tracks traversed objects.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Unordered comparison
   *  2 - Partial comparison
   * @param {Function} [customizer] The function to customize comparisons.
   * @param {Object} [stack] Tracks traversed `value` and `other` objects.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   */
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$4 = 1,
      COMPARE_UNORDERED_FLAG$2 = 2;

  /**
   * The base implementation of `_.isMatch` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to inspect.
   * @param {Object} source The object of property values to match.
   * @param {Array} matchData The property names, values, and compare flags to match.
   * @param {Function} [customizer] The function to customize comparisons.
   * @returns {boolean} Returns `true` if `object` is a match, else `false`.
   */
  function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length,
        length = index,
        noCustomizer = !customizer;

    if (object == null) {
      return !length;
    }
    object = Object(object);
    while (index--) {
      var data = matchData[index];
      if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
        return false;
      }
    }
    while (++index < length) {
      data = matchData[index];
      var key = data[0],
          objValue = object[key],
          srcValue = data[1];

      if (noCustomizer && data[2]) {
        if (objValue === undefined && !(key in object)) {
          return false;
        }
      } else {
        var stack = new Stack();
        if (customizer) {
          var result = customizer(objValue, srcValue, key, object, source, stack);
        }
        if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$4 | COMPARE_UNORDERED_FLAG$2, customizer, stack) : result)) {
          return false;
        }
      }
    }
    return true;
  }

  /**
   * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` if suitable for strict
   *  equality comparisons, else `false`.
   */
  function isStrictComparable(value) {
    return value === value && !isObject(value);
  }

  /**
   * Gets the property names, values, and compare flags of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the match data of `object`.
   */
  function getMatchData(object) {
    var result = keys(object),
        length = result.length;

    while (length--) {
      var key = result[length],
          value = object[key];

      result[length] = [key, value, isStrictComparable(value)];
    }
    return result;
  }

  /**
   * A specialized version of `matchesProperty` for source values suitable
   * for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @param {*} srcValue The value to match.
   * @returns {Function} Returns the new spec function.
   */
  function matchesStrictComparable(key, srcValue) {
    return function (object) {
      if (object == null) {
        return false;
      }
      return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
    };
  }

  /**
   * The base implementation of `_.matches` which doesn't clone `source`.
   *
   * @private
   * @param {Object} source The object of property values to match.
   * @returns {Function} Returns the new spec function.
   */
  function baseMatches(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function (object) {
      return object === source || baseIsMatch(object, source, matchData);
    };
  }

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/;

  /**
   * Checks if `value` is a property name and not a property path.
   *
   * @private
   * @param {*} value The value to check.
   * @param {Object} [object] The object to query keys on.
   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
   */
  function isKey(value, object) {
    if (isArray(value)) {
      return false;
    }
    var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }

  /** Error message constants. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * provided, it determines the cache key for storing the result based on the
   * arguments provided to the memoized function. By default, the first argument
   * provided to the memoized function is used as the map cache key. The `func`
   * is invoked with the `this` binding of the memoized function.
   *
   * **Note:** The cache is exposed as the `cache` property on the memoized
   * function. Its creation may be customized by replacing the `_.memoize.Cache`
   * constructor with one whose instances implement the
   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
   * method interface of `clear`, `delete`, `get`, `has`, and `set`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] The function to resolve the cache key.
   * @returns {Function} Returns the new memoized function.
   * @example
   *
   * var object = { 'a': 1, 'b': 2 };
   * var other = { 'c': 3, 'd': 4 };
   *
   * var values = _.memoize(_.values);
   * values(object);
   * // => [1, 2]
   *
   * values(other);
   * // => [3, 4]
   *
   * object.a = 2;
   * values(object);
   * // => [1, 2]
   *
   * // Modify the result cache.
   * values.cache.set(object, ['a', 'b']);
   * values(object);
   * // => ['a', 'b']
   *
   * // Replace `_.memoize.Cache`.
   * _.memoize.Cache = WeakMap;
   */
  function memoize(func, resolver) {
    if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function memoized() {
      var args = arguments,
          key = resolver ? resolver.apply(this, args) : args[0],
          cache = memoized.cache;

      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
  }

  // Expose `MapCache`.
  memoize.Cache = MapCache;

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /**
   * A specialized version of `_.memoize` which clears the memoized function's
   * cache when it exceeds `MAX_MEMOIZE_SIZE`.
   *
   * @private
   * @param {Function} func The function to have its output memoized.
   * @returns {Function} Returns the new memoized function.
   */
  function memoizeCapped(func) {
    var result = memoize(func, function (key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key;
    });

    var cache = result.cache;
    return result;
  }

  /** Used to match property names within property paths. */
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Converts `string` to a property path array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the property path array.
   */
  var stringToPath = memoizeCapped(function (string) {
    var result = [];
    if (string.charCodeAt(0) === 46 /* . */) {
        result.push('');
      }
    string.replace(rePropName, function (match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
    });
    return result;
  });

  /**
   * Casts `value` to a path array if it's not one.
   *
   * @private
   * @param {*} value The value to inspect.
   * @param {Object} [object] The object to query keys on.
   * @returns {Array} Returns the cast property path array.
   */
  function castPath(value, object) {
    if (isArray(value)) {
      return value;
    }
    return isKey(value, object) ? [value] : stringToPath(toString(value));
  }

  /** Used as references for various `Number` constants. */
  var INFINITY$2 = 1 / 0;

  /**
   * Converts `value` to a string key if it's not a string or symbol.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {string|symbol} Returns the key.
   */
  function toKey(value) {
    if (typeof value == 'string' || isSymbol(value)) {
      return value;
    }
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY$2 ? '-0' : result;
  }

  /**
   * The base implementation of `_.get` without support for default values.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @returns {*} Returns the resolved value.
   */
  function baseGet(object, path) {
    path = castPath(path, object);

    var index = 0,
        length = path.length;

    while (object != null && index < length) {
      object = object[toKey(path[index++])];
    }
    return index && index == length ? object : undefined;
  }

  /**
   * Gets the value at `path` of `object`. If the resolved value is
   * `undefined`, the `defaultValue` is returned in its place.
   *
   * @static
   * @memberOf _
   * @since 3.7.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @param {*} [defaultValue] The value returned for `undefined` resolved values.
   * @returns {*} Returns the resolved value.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c': 3 } }] };
   *
   * _.get(object, 'a[0].b.c');
   * // => 3
   *
   * _.get(object, ['a', '0', 'b', 'c']);
   * // => 3
   *
   * _.get(object, 'a.b.c', 'default');
   * // => 'default'
   */
  function get(object, path, defaultValue) {
    var result = object == null ? undefined : baseGet(object, path);
    return result === undefined ? defaultValue : result;
  }

  /**
   * The base implementation of `_.hasIn` without support for deep paths.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {Array|string} key The key to check.
   * @returns {boolean} Returns `true` if `key` exists, else `false`.
   */
  function baseHasIn(object, key) {
    return object != null && key in Object(object);
  }

  /**
   * Checks if `path` exists on `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @param {Function} hasFunc The function to check properties.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   */
  function hasPath(object, path, hasFunc) {
    path = castPath(path, object);

    var index = -1,
        length = path.length,
        result = false;

    while (++index < length) {
      var key = toKey(path[index]);
      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }
      object = object[key];
    }
    if (result || ++index != length) {
      return result;
    }
    length = object == null ? 0 : object.length;
    return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
  }

  /**
   * Checks if `path` is a direct or inherited property of `object`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   * @example
   *
   * var object = _.create({ 'a': _.create({ 'b': 2 }) });
   *
   * _.hasIn(object, 'a');
   * // => true
   *
   * _.hasIn(object, 'a.b');
   * // => true
   *
   * _.hasIn(object, ['a', 'b']);
   * // => true
   *
   * _.hasIn(object, 'b');
   * // => false
   */
  function hasIn(object, path) {
    return object != null && hasPath(object, path, baseHasIn);
  }

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$5 = 1,
      COMPARE_UNORDERED_FLAG$3 = 2;

  /**
   * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
   *
   * @private
   * @param {string} path The path of the property to get.
   * @param {*} srcValue The value to match.
   * @returns {Function} Returns the new spec function.
   */
  function baseMatchesProperty(path, srcValue) {
    if (isKey(path) && isStrictComparable(srcValue)) {
      return matchesStrictComparable(toKey(path), srcValue);
    }
    return function (object) {
      var objValue = get(object, path);
      return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$5 | COMPARE_UNORDERED_FLAG$3);
    };
  }

  /**
   * This method returns the first argument it receives.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'a': 1 };
   *
   * console.log(_.identity(object) === object);
   * // => true
   */
  function identity(value) {
    return value;
  }

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function (object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * A specialized version of `baseProperty` which supports deep paths.
   *
   * @private
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyDeep(path) {
    return function (object) {
      return baseGet(object, path);
    };
  }

  /**
   * Creates a function that returns the value at `path` of a given object.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new accessor function.
   * @example
   *
   * var objects = [
   *   { 'a': { 'b': 2 } },
   *   { 'a': { 'b': 1 } }
   * ];
   *
   * _.map(objects, _.property('a.b'));
   * // => [2, 1]
   *
   * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
   * // => [1, 2]
   */
  function property(path) {
    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
  }

  /**
   * The base implementation of `_.iteratee`.
   *
   * @private
   * @param {*} [value=_.identity] The value to convert to an iteratee.
   * @returns {Function} Returns the iteratee.
   */
  function baseIteratee(value) {
    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
    if (typeof value == 'function') {
      return value;
    }
    if (value == null) {
      return identity;
    }
    if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object') {
      return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
    }
    return property(value);
  }

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG$1 = 1;

  /**
   * Creates a function that invokes `func` with the arguments of the created
   * function. If `func` is a property name, the created function returns the
   * property value for a given element. If `func` is an array or object, the
   * created function returns `true` for elements that contain the equivalent
   * source properties, otherwise it returns `false`.
   *
   * @static
   * @since 4.0.0
   * @memberOf _
   * @category Util
   * @param {*} [func=_.identity] The value to convert to a callback.
   * @returns {Function} Returns the callback.
   * @example
   *
   * var users = [
   *   { 'user': 'barney', 'age': 36, 'active': true },
   *   { 'user': 'fred',   'age': 40, 'active': false }
   * ];
   *
   * // The `_.matches` iteratee shorthand.
   * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
   * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.filter(users, _.iteratee(['user', 'fred']));
   * // => [{ 'user': 'fred', 'age': 40 }]
   *
   * // The `_.property` iteratee shorthand.
   * _.map(users, _.iteratee('user'));
   * // => ['barney', 'fred']
   *
   * // Create custom iteratee shorthands.
   * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
   *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
   *     return func.test(string);
   *   };
   * });
   *
   * _.filter(['abc', 'def'], /ef/);
   * // => ['def']
   */
  function iteratee(func) {
    return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG$1));
  }

  function ascending (a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  function bisector (compare) {
    if (compare.length === 1) compare = ascendingComparator(compare);
    return {
      left: function left(a, x, lo, hi) {
        if (lo == null) lo = 0;
        if (hi == null) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) < 0) lo = mid + 1;else hi = mid;
        }
        return lo;
      },
      right: function right(a, x, lo, hi) {
        if (lo == null) lo = 0;
        if (hi == null) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) > 0) hi = mid;else lo = mid + 1;
        }
        return lo;
      }
    };
  }

  function ascendingComparator(f) {
    return function (d, x) {
      return ascending(f(d), x);
    };
  }

  var ascendingBisect = bisector(ascending);

  function extent (values, valueof) {
    var min = void 0;
    var max = void 0;
    if (valueof === undefined) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var value = _step.value;

          if (value != null) {
            if (min === undefined) {
              if (value >= value) min = max = value;
            } else {
              if (min > value) min = value;
              if (max < value) max = value;
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    } else {
      var index = -1;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = values[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _value = _step2.value;

          if ((_value = valueof(_value, ++index, values)) != null) {
            if (min === undefined) {
              if (_value >= _value) min = max = _value;
            } else {
              if (min > _value) min = _value;
              if (max < _value) max = _value;
            }
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
    return [min, max];
  }

  /*
  ## scale

  Converts a configuration into a d3 scale function. This is used to extract a
  different value for each data point. For example:

  ```js
  var color_scale = g1.scale({
    metric: 'age',
    scheme: 'RdYlGn'
  }, data)
  // Returns a color scale that maps the age column to the red - yellow - green color scheme
  ```

  ### scale attributes

  - metric can be one of:
    - string: column name
    - `function(d, i)` that returns a value for each item in the data
  - scheme: color scheme to interpolate to
  - scale: d3 scale to use. Defaults to linear
  - range: set the range of the scale
  - domain: override the domain (which defaults to the extent of the data metric)

  NEW SPEC:
  - scale: 'linear' or 'quantile'
  - domain: {metric: 'col_name'}
  - range: for array or {scheme: 'Blues', count: 6}


  TODO:
  - Support multi-metric domains
  - Support order_by on aggregate of metrics
  - Support clamp, round for quantitative scales
  - Support nice
  */

  var scale_types = {
    'Ordinal': 'discrete',
    'Band': 'discrete',
    'Point': 'discrete',
    'Linear': 'continuous',
    'Log': 'continuous',
    'Pow': 'continuous',
    'Sqrt': 'continuous',
    'Sequential': 'continuous',
    'Quantile': 'quantile', // Exception because domain is entire dataset
    'Quantize': 'discretizing',
    'Threshold': 'discretizing'
  },
      renames = { Sequential: 'Linear' },
      domain_function = {
    discrete: uniq,
    quantile: function quantile(d) {
      return d;
    },
    discretizing: extent,
    continuous: extent
  };

  function backward_compat(config, _scale) {
    if (config.scheme && !Array.isArray(config.range)) {
      config.range = { scheme: config.scheme };
      if (scale_types[_scale] != 'continuous' && config.count) config.range.count = config.count;
    }
    if (!config.domain) config.domain = { metric: config.metric };
    config.metric = config.domain.metric || config.metric;
    return config;
  }

  function get_domain(data, config_domain, metric, scale) {
    return Array.isArray(config_domain) && scale != 'Quantile' ? config_domain : domain_function[scale_types[scale]](data.map(iteratee(metric)));
  }

  function get_range(config_range, _scale) {
    return Array.isArray(config_range) ? config_range : scale_types[_scale] == 'continuous' ? [0, 1] : get_colors_from_scheme(get_scheme(config_range.scheme), config_range.count);
  }

  function flip(array, reverse) {
    return reverse ? array.slice().reverse() : array;
  }

  function get_scheme(scheme) {
    return d3[scheme.startsWith('scheme') ? scheme : 'scheme' + upperFirst(scheme)];
  }

  function get_colors_from_scheme(scheme, count) {
    // For discrete colors ranges, like schemeBlues, k value is [3, 9]. So, the first 3 values are empty
    return Object.values(scheme).length !== scheme.length ? scheme[count ? count : scheme.length - 1] : scheme;
  }

  function scale(data, config) {
    var _scale = upperFirst(config.scale || 'Linear');

    config = backward_compat(config, _scale);

    var result = d3['scale' + (renames[_scale] || _scale)]().domain(get_domain(data, config.domain, config.metric, _scale)).range(flip(get_range(config.range, _scale), config.range.reverse === true || config.reverse));

    return scale_types[_scale] == 'continuous' && !Array.isArray(config.range) ? function (val) {
      return d3['interpolate' + config.range.scheme](result((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' ? iteratee(config.metric)(val) : val));
    } : function (val) {
      return result((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' ? iteratee(config.metric)(val) : val);
    };
  }

  /* This is extracted from

  https://github.com/d3/d3-interpolate/blob/master/src/transform/parse.js
  https://github.com/d3/d3-interpolate/blob/master/src/transform/decompose.js

  TODO: import parseSvg directly from d3 instead of re-writing.

  */
  var svgNode;
  var degrees = 180 / Math.PI;
  var identity$1 = { translateX: 0, translateY: 0 };

  function parseSvg(value) {
    if (value == null) return identity$1;
    if (!svgNode) svgNode = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    svgNode.setAttribute('transform', value);
    if (!(value = svgNode.transform.baseVal.consolidate())) return identity$1;
    value = value.matrix;
    return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
  }

  function decompose(a, b, c, d, e, f) {
    var scaleX, scaleY, skewX;
    if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
    if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
    if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
    if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
    return {
      translateX: e,
      translateY: f,
      rotate: Math.atan2(b, a) * degrees,
      skewX: Math.atan(skewX) * degrees,
      scaleX: scaleX,
      scaleY: scaleY
    };
  }

  function SanddanceException(message, options) {
    this.message = message;
    this.options = options;
  }
  function pop(dict, key, value) {
    if (key in dict) {
      value = dict[key];
      delete dict[key];
    }
    return value;
  }
  // A replacement for Object.assign()
  function copy(target) {
    for (var i = 1, l = arguments.length; i < l; i++) {
      var source = arguments[i];
      for (var key in source) {
        target[key] = source[key];
      }
    }
    return target;
  }
  // Distance between two points
  function dist(x1, y1, x2, y2) {
    var dx = x2 - x1;
    var dy = y2 - y1;
    return Math.sqrt(dx * dx + dy * dy);
  }
  // Return the indices of data when data is sorted by a column (str or fn),
  // with order specified by ascending=true (default) or false
  function sort(data, column, ascending) {
    // indices[i] will give us the sorted position of the i-th item
    var indices = data.map(function (d, i) {
      return i;
    });
    if (column) {
      // items is a list of [sort_value, index] which we use for a stable sort
      var items = data.map(typeof column == 'function' ? function (d, i) {
        return [column(d), i];
      } : function (d, i) {
        return [d[column], i];
      });
      // sort the indices using a stable sort
      indices.sort(function (a, b) {
        var val1 = items[a][0],
            val2 = items[b][0];
        return val1 < val2 ? -1 : val1 > val2 ? +1 : items[a][1] - items[b][1];
      });
      // invert the indices in ascending or descending order
      ascending = !ascending && typeof ascending != 'undefined';
      for (var i = 0, l = indices.length, inv = []; i < l; i++) {
        inv[indices[i]] = ascending ? i : l - i - 1;
      }indices = inv;
    }
    return indices;
  }

  // If an options value is an object, treat it as a scale configuration.
  // Replace it with the scale function
  function update_scale(data, options) {
    for (var key in options) {
      if (_typeof(options[key]) == 'object') options[key] = scale(data, options[key]);
    }return options;
  }

  var namespace$1 = '.sanddance';
  var layout_map = {
    grid: sanddance_grid,
    hexpack: sanddance_hexpack,
    spiral: sanddance_spiral
  };

  function sanddance(attrs, options) {
    options = options || {};
    var dispatch = d3.dispatch('init', 'start', 'end');
    var layout_props;
    if (options.layout) {
      layout_props = layout_map[options.layout](attrs, options);
      attrs = layout_props.attrs;
      options = layout_props.options;
    }
    var duration = options.duration;
    var speed = options.speed;
    var delay = options.delay || 0;
    var easing = options.easing || d3.easeLinear;
    var filter = options.filter;
    var x = options.x;
    var y = options.y;

    var result = function result(selection) {
      dispatch.call('init', selection);
      var filtered = filter ? selection.filter(filter) : selection;

      var transition = filtered.transition().ease(easing);

      if (x || y) {
        var x_fn = typeof x == 'function' ? x : function () {
          return x;
        };
        var y_fn = typeof y == 'function' ? y : function () {
          return y;
        };
        transition.attr('transform', function (d, i) {
          var x = x_fn(d, i);
          var y = y_fn(d, i);
          this.dataset['_sd_x'] = x;
          this.dataset['_sd_y'] = y;
          return 'translate(' + x + ',' + y + ')';
        });
      }

      for (var key in attrs) {
        transition = transition.attr(key, attrs[key]);
      } // Note: duration = 0 is a valid duration
      if ('duration' in options) transition = transition.duration(duration);else if (speed) transition = transition.duration(function (d) {
        var transform = parseSvg(this.getAttribute('transform'));
        var x1 = transform.translateX;
        var y1 = transform.translateY;
        // TODO (Anand): Need a better way of identifying where the element will be
        // across transforms and setting x, y
        var x2 = this.dataset['_sd_x'];
        var y2 = this.dataset['_sd_y'];
        var distance = dist(x1, y1, x2, y2);
        var _speed = typeof speed == 'function' ? speed(d) : speed;
        return distance / _speed * 1000;
      });

      if (delay) transition = transition.delay(function (d) {
        return typeof delay == 'function' ? delay(d) : delay;
      });

      // Set up event handling.
      // sanddance.on('start') is triggered when the first transition begins
      var count_end = filtered.size(),
          count_start = 0;
      transition.on('start.count', function () {
        if (count_start === 0) dispatch.call('start', selection);
        count_start++;
      });
      // sanddance.on('end') is triggered when the last transition stops (ends / interrupted)
      transition.on('end interrupt', function () {
        count_end--;
        if (count_end > 0) return;else if (count_end === 0) return dispatch.call('end', selection);else throw new SanddanceException('sanddance: Invalid count: ' + count_end, options);
      });
    };
    result.on = function (event, callback) {
      dispatch.on(event + namespace$1, callback);
      return result;
    };
    // Returns a new sanddance with updated attributes
    result.update = function (update_attrs, update_options) {
      return sanddance(copy({}, attrs, update_attrs), copy({}, options, update_options));
    };
    return result;
  }

  sanddance.chain = function () {
    for (var i = 0, l = arguments.length - 1; i < l; i++) {
      (function (prev, next) {
        prev.on('end' + namespace$1, function () {
          this.call(next);
        });
      })(arguments[i], arguments[i + 1]);
    }
    return arguments[0];
  };

  function sanddance_grid(attrs, options) {
    var data = options.data;
    var width = options.width;
    var height = options.height;
    var area = width * height / data.length;
    var element_width = Math.sqrt(area);
    var elements_per_row = Math.ceil(width / element_width);
    var num_rows = Math.ceil(data.length / elements_per_row);
    var element_height = element_width * num_rows;
    var filter = options.filter;
    data = filter ? data.filter(function (d, i) {
      return filter(d, i);
    }) : data;
    var indices = sort(data, options.sort, options.ascending);

    attrs.transform = function (d, i) {
      // TODO: pre-compute these into a pos[] array
      i = indices[i];
      var col = i % elements_per_row;
      var row = Math.floor(i / elements_per_row);
      var x = this.dataset['_sd_x'] = col * element_width;
      var y = this.dataset['_sd_y'] = element_height - (row + 1) * element_width;
      return 'translate(' + x + ',' + y + ')';
    };
    return { attrs: update_scale(data, attrs), options: options };
  }

  function sanddance_hexpack(attrs, options) {
    var data = options.data;
    var filter = options.filter;
    data = filter ? data.filter(function (d, i) {
      return filter(d, i);
    }) : data;
    var indices = sort(data, options.sort, options.sort_ascending);
    var count = data.length;
    var pos = [[0, 0]],
        l = 1,
        // level
    n = 0,
        // number of items filled so far
    i;
    while (n < count) {
      for (i = 0; i >= 1 - l; i--) {
        pos.push([l, i]);
      } // top-right
      for (i = l; i >= 1; i--) {
        pos.push([i, -l]);
      } // top
      for (i = 0; i >= 1 - l; i--) {
        pos.push([i, -l - i]);
      } // top left
      for (i = 0; i <= l - 1; i++) {
        pos.push([-l, i]);
      } // bottom left
      for (i = -l; i <= -1; i++) {
        pos.push([i, l]);
      } // bottom
      for (i = 0; i <= l - 1; i++) {
        pos.push([i, l - i]);
      } // bottom right
      n += l * 6; // increment number of items filled
      l++; // move to next level
    }
    // Pre-compute positions
    var width = options.width;
    var height = options.height;
    var diameter = 2 * l - 1;
    var size_x = width / diameter;
    var size_y = height / diameter;
    var cos = size_x * Math.cos(Math.PI * 60 / 180);
    var sin = size_y * Math.sin(Math.PI * 60 / 180);
    pos = pos.slice(0, count).map(function (row) {
      return [row[0] * size_x + row[1] * cos + width / 2, row[1] * sin + height / 2];
    });
    attrs.transform = function (d, i) {
      i = indices[i];
      var p = pos[i];
      return 'translate(' + p[0] + ',' + p[1] + ')';
    };
    return { attrs: update_scale(data, attrs), options: options };
  }

  function sanddance_spiral(attrs, options) {
    var data = options.data;
    var filter = options.filter;
    data = filter ? data.filter(function (d, i) {
      return filter(d, i);
    }) : data;
    var indices = sort(data, options.sort, options.sort_ascending);
    var radius = pop(options, 'spiral_size');
    var angle = pop(options, 'spiral_angle') * Math.PI / 180;
    var pos = data.map(function (d, i) {
      return [i * radius * Math.cos(i * angle), i * radius * Math.sin(i * angle)];
    });
    attrs.transform = function (d, i) {
      i = indices[i];
      return 'translate(' + pos[i][0] + ',' + pos[i][1] + ')';
    };
    return { attrs: update_scale(data, attrs), options: options };
  }

  /*
    url.parse() provides results consistent with window.location.

    0 href                Full URL source
    1 protocol            http, https, etc
    2 origin              username:password@hostname:port
    4 username            username
    5 password            password
    - host                NOT IMPLEMENTED
    6 hostname            hostname
    7 port                port
    9 pathname            full path, excluding hash
    12 search              search parameters
    13 hash                url fragment

    The following are not part of window.location, but provided anyway.

    3 userinfo            username:password
    8 relative:           Everything after origin
    10 directory:          Directory part of pathname
    11 file:               File part of pathname
      - searchKey           search as an ordered dict of strings
      - searchList          search as an ordered dict of arrays
    */

  var _url_parse_key = ['href', 'protocol', 'origin', 'userinfo', 'username', 'password', 'hostname', 'port', 'relative', 'pathname', 'directory', 'file', 'search', 'hash'],
      _url_parse_qname = ['searchKey', 'searchList'],
      _url_parse_strict = /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
      // eslint-disable-line
  _url_parse_search = /(?:^|&)([^&=]*)=?([^&]*)/g;

  var _decode_uri_component = function _decode_uri_component(s) {
    return decodeURIComponent(s.replace(/\+/g, '%20'));
  },
      _encode_uri_component = encodeURIComponent;

  function parse(str) {
    /* Based on parseUri 1.2.2: http://blog.stevenlevithan.com/archives/parseuri
      MIT License
    */
    var uri = {
      toString: unparse,
      join: join,
      update: update
    },
        m = _url_parse_strict.exec(str || ''),
        i = 14;

    while (i--) {
      uri[_url_parse_key[i]] = m[i] || '';
    }var search_key = uri[_url_parse_qname[0]] = {},
        search_list = uri[_url_parse_qname[1]] = {};
    uri[_url_parse_key[12]].replace(_url_parse_search, function ($0, key, val) {
      if (key) {
        key = _decode_uri_component(key);
        val = _decode_uri_component(val);
        search_key[key] = val;
        search_list[key] = search_list[key] || [];
        search_list[key].push(val);
      }
    });

    return uri;
  }

  // Converts the URL parts back into the original URL.
  function unparse(self) {
    self = self || this;
    var protocol = self[_url_parse_key[1]] || 'http',
        username = self[_url_parse_key[4]],
        password = self[_url_parse_key[5]],
        hostname = self[_url_parse_key[6]],
        port = self[_url_parse_key[7]],
        pathname = self[_url_parse_key[9]],
        search = self[_url_parse_key[12]],
        hash = self[_url_parse_key[13]],
        search_key = self[_url_parse_qname[0]],
        search_list = self[_url_parse_qname[1]],
        parts = hostname ? [protocol, '://'] : [],
        qparts = [],
        key,
        vals,
        i,
        l;
    if (username) {
      parts.push(username);
      if (password) parts.push(':', password);
      parts.push('@');
    }
    parts.push(hostname);
    if (port) parts.push(':', port);
    parts.push(pathname || (hostname ? '/' : ''));
    if (search) {
      parts.push('?', search);
    } else {
      if (search_list) {
        for (key in search_list) {
          for (i = 0, vals = search_list[key], l = vals.length; i < l; i++) {
            qparts.push(_encode_uri_component(key) + '=' + _encode_uri_component(vals[i]));
          }
          if (!l) qparts.push(key);
        }
      } else if (search_key) {
        for (key in search_key) {
          qparts.push(_encode_uri_component(key) + '=' + _encode_uri_component(search_key[key]));
        }
      }
      if (qparts.length) parts.push('?', qparts.join('&'));
    }
    if (hash) parts.push('#', hash);

    return parts.join('');
  }

  function join(urlstr, options) {
    options = options || {};
    var self = this,
        sources = self[_url_parse_key[9]].split('/'),
        // self.pathname.split
    ptr = sources.length - 1,
        // Points to last element
    url = parse(urlstr),
        targets = url.pathname.split('/'),
        l = targets.length,
        i,
        frag;

    if (typeof options.query == 'undefined') options.query = true;
    if (typeof options.hash == 'undefined') options.hash = true;

    for (i = 0; i < 14; i++) {
      if (i == 9) continue; // Ignore path
      if (i == 12 && !options.query) continue; // Ignore search parameters
      if (i == 13 && !options.hash) continue; // Ignore url fragment
      if (url[_url_parse_key[i]]) self[_url_parse_key[i]] = url[_url_parse_key[i]];
    }
    if (options.query && url[_url_parse_key[12]]) {
      // Copy search parameters
      self[_url_parse_qname[0]] = url[_url_parse_qname[0]];
      self[_url_parse_qname[1]] = url[_url_parse_qname[1]];
    }
    for (i = 0; i < l; i++) {
      frag = targets[i];
      if (frag == '.') {
        sources[ptr] = '';
      } else if (frag == '..') {
        sources[--ptr] = '';
      } else if (frag === '') {
        // Ignore blank urlstr
        if (l > 1) {
          // Leading slash clears the URL
          if (!i) {
            sources[0] = frag;
            ptr = 1;
          }
          // Trailing slash is appended
          if (i == l - 1) sources[ptr] = frag;
        }
      } else {
        sources[ptr] = frag;
        if (i < l - 1) ptr++;
      }
    }

    // Set .pathname, .directory, .file.
    var path = self[_url_parse_key[9]] = sources.slice(0, ptr + 1).join('/'),
        parts = path.split(/\//),
        relative = [path];
    if (self[_url_parse_key[12]]) relative.push('?', self[_url_parse_key[12]]);
    if (self[_url_parse_key[13]]) relative.push('#', self[_url_parse_key[13]]);
    self[_url_parse_key[8]] = relative.join(''); // relative
    self[_url_parse_key[10]] = parts.slice(0, parts.length - 1).join('/') + '/'; // directory
    self[_url_parse_key[11]] = parts[parts.length - 1]; // file

    return self;
  }

  function update(args, mode) {
    var self = this,
        search_key = self[_url_parse_qname[0]],
        search_list = self[_url_parse_qname[1]],
        qparts = [],
        modes = {},
        key,
        val,
        i,
        l,
        hash,
        search_list_key,
        result;

    if (mode) {
      // Ensure that mode is a string
      mode = '' + mode;
      // If the mode is like a=add&b=toggle, treat it like URL search params and
      // convert it into a dictionary
      if (mode.match(/[&=]/)) modes = parse('?' + mode).searchKey;
      // If the mode is just a string like add, del, toggle, apply it to all keys
      else for (key in args) {
          modes[key] = mode;
        }
    }

    for (key in args) {
      val = args[key];
      if (val === null) {
        search_list[key] = [];
      } else {
        if (!Array.isArray(val)) val = [val];
        if (!modes[key]) search_list[key] = val;else {
          // Ensure that search_list[key] exists
          if (!(key in search_list)) search_list[key] = [];

          // Prepare a hash for lookup
          for (hash = {}, i = 0, l = val.length; i < l; i++) {
            hash[val[i].toString()] = 1;
          } // Ensure that mode is a string
          mode = '' + modes[key];

          if (mode.match(/add/i)) search_list[key] = search_list[key].concat(val);

          // mode=del deletes all matching values
          else if (mode.match(/del/i)) {
              for (result = [], search_list_key = search_list[key], i = 0, l = search_list_key.length; i < l; i++) {
                if (!hash[search_list_key[i]]) result.push(search_list_key[i]);
              }
              search_list[key] = result;
            }

            // mode=toggle deletes matching values, adds the rest
            else if (mode.match(/toggle/i)) {
                for (result = [], search_list_key = search_list[key], i = 0, l = search_list_key.length; i < l; i++) {
                  if (hash[search_list_key[i]]) hash[search_list_key[i]] = 2; // Mark it as present
                  else result.push(search_list_key[i]);
                }
                // Append the unmarked values
                for (val in hash) {
                  if (hash[val] == 1) result.push(val);
                }search_list[key] = result;
              }
        }
      }
      if (search_list[key].length === 0) {
        delete search_key[key];
        delete search_list[key];
      } else {
        search_key[key] = search_list[key][search_list[key].length - 1];
      }
    }
    for (key in search_list) {
      val = search_list[key];
      for (i = 0, l = val.length; i < l; i++) {
        qparts.push(_encode_uri_component(key) + '=' + _encode_uri_component(val[i]));
      }
    }
    self.search = qparts.join('&');
    return self;
  }

  // jQuery utilities.
  // These are NOT jQuery plugins. They accept a $node directly.
  // These are NOT exposed as part of the API. Purely internal.

  // Return all values that match the selector
  // AMONG and UNDER the $node
  function findall($node, selector) {
    return $node.filter(selector).add($node.find(selector));
  }

  // Returns true if data attribute is present
  //    But if the value is "false", "off", "n" or "no" in any case, returns false (like YAML)
  // Returns default_value if data attribute is missing
  function hasdata($node, key, default_value) {
    var val = $node.data(key);
    if (typeof val == 'undefined' || val === false || val === null) return default_value;
    if (typeof val == 'string' && val.match(/^(false|off|n|no)$/i)) return false;
    return true;
  }

  var container_options = {
    attr: 'href',
    event: 'click change submit',
    selector: '.urlfilter',
    src: 'src'
  };
  var event_namespace = '.urlfilter';

  function urlfilter(options) {
    var $self = this;
    // If there are no elements in the selection, exit silently
    if ($self.length == 0) return;
    var doc = $self[0].ownerDocument;
    var settings = $.extend({}, container_options, options || {}, this.dataset);
    var default_remove = settings.remove || hasdata($self, 'remove');
    var events = settings.event.split(/\s+/).map(function (v) {
      return v + event_namespace;
    }).join(' ');
    // options.location and options.history are used purely for testing
    var loc = settings.location || (doc.defaultView || doc.parentWindow).location;
    var hist = settings.history || (doc.defaultView || doc.parentWindow).history;
    return $self.on(events, settings.selector, function (e) {
      var $this = $(this),
          mode = $this.data('mode') || settings.mode,
          target = $this.data('target') || settings.target,
          src = $this.data('src') || settings.src,
          remove = hasdata($this, 'remove', default_remove),
          href;
      if (e.type == 'change' || $(e.target).is(':input:not(:button)')) {
        var key = encodeURIComponent($this.attr('id') || $this.attr('name'));
        var val = encodeURIComponent($this.val());
        href = '?' + key + '=' + val;
      } else if (e.type == 'submit' || $(e.target).is('form')) {
        e.preventDefault();
        href = '?' + $this.serialize();
      } else if (e.type == 'click') {
        if ($(e.target).is('a')) e.preventDefault();
        href = $this.attr(settings.attr);
      } else return;

      var url = parse(href),
          q = url.searchList;

      function target_url(url) {
        var result = parse(url).join(href, { query: false, hash: false }).update(q, mode);
        if (remove) {
          var missing_keys = {};
          for (var key in result.searchKey) {
            if (result.searchKey[key] === '') missing_keys[key] = null;
          }result.update(missing_keys);
        }
        return result.toString();
      }

      // If the target is...       the URL is get/set at
      // ------------------------  ---------------------
      // unspecified (=> window)   location.href
      // 'pushState'               location.href
      // '#'                       location.hash
      // anything else             $(target).data(src)
      if (!target) loc.href = target_url(loc.href);else if (target == '#') loc.hash = target_url(loc.hash.replace(/^#/, ''));else if (target.match(/^pushstate$/i)) hist.pushState({}, '', target_url(loc.href));else {
        $(target).each(function () {
          var $target = $(this);
          var url = target_url($target.attr(src));
          $target.attr(src, url).load(url, function () {
            $target.trigger({ type: 'load', url: url });
          });
        });
      }
      $this.trigger({ type: 'urlfilter', url: url });
    });
  }

  var url = {
    parse: parse,
    unparse: unparse,
    join: join,
    update: update
  };

  if (typeof jQuery != 'undefined') {
    jQuery.extend(jQuery.fn, {
      urlfilter: urlfilter
    });
  }

  function ajaxchain(request, $self, requests, responses) {
    $self = $self || $('<div>');
    requests = requests || [];
    responses = responses || [];
    if (!('limit' in request)) request.limit = 10;
    request.limit--;
    $.ajax(request).done(function (response, status, xhr) {
      requests.push(request);
      responses.push(response);
      $self.trigger({ type: 'load', request: request, response: response, xhr: xhr });
      if (request.chain && request.limit > 0) {
        try {
          var updates = request.chain(response, request, xhr);
        } catch (e) {
          $self.trigger({ type: 'error', request: request, xhr: xhr, exception: e });
          // eslint-disable-next-line no-console
          console.warn('$.ajaxchain: chain() exception', e);
        }
        if ($.isPlainObject(updates) && !$.isEmptyObject(updates)) {
          var new_request = $.extend(true, {}, request, updates);
          var next = ajaxchain(new_request, $self, requests, responses);
        }
      }
      if (!next) $self.trigger({ type: 'done', request: requests, response: responses });
    }).fail(function (xhr, testStatus, error) {
      $self.trigger({ type: 'error', request: request, xhr: xhr });
      $self.trigger({ type: 'done', request: requests, response: responses });
      // eslint-disable-next-line no-console
      console.warn('$.ajaxchain: ajax error', error);
    });
    return $self;
  }

  // Chain through a list of URLs in order
  ajaxchain.list = function (urls) {
    return function (response, request) {
      var next = urls.indexOf(request.url) + 1;
      if (next < urls.length) return { url: urls[next] };
    };
  };

  // Used by Twitter, YouTube
  // Google:    .cursor('data.pageToken', 'nextPageToken')
  // Twitter:   .cursor('data.cursor', 'next_cursor')
  // Facebook:  .cursor('url', 'paging.next')
  if (typeof _ == 'undefined') ajaxchain.cursor = function () {
    throw new Error('ajaxchain.cursor requires lodash');
  };else ajaxchain.cursor = function (target, source) {
    return function (response) {
      var key = _.get(response, source);
      if (key) return _.set({}, target, key);
    };
  };

  if (typeof jQuery != 'undefined') {
    jQuery.extend(jQuery, {
      ajaxchain: ajaxchain
    });
  }

  var template_dropdown = "<% var urlfilterClass = key ? 'urlfilter' : '',\nmultiple = multiple ? 'multiple' : '',\nkey = key ? key : '' %> <select class=\"selectpicker border <%- urlfilterClass %>\" id=\"<%- key %>\" <%-multiple%>></select>";
  var template_dropdown_options = "<% _.each(data, function(item) { %> <option value=\"<%- item %>\"><%- item %></option> <% }) %>";
  var template_dropdown_object = "<% _.each(data, function(item) { %> <option value=\"<%- item[value_key] %>\" label=\"<%- item[label_key] %>\"><%- item[label_key] %></option> <% }) %>";
  var template_error = "<div class=\"alert alert-warning\" role=\"alert\"><p class=\"text-center\"> <%- message %> </p></div>";

  var default_templates = /*#__PURE__*/Object.freeze({
    template_dropdown: template_dropdown,
    template_dropdown_options: template_dropdown_options,
    template_dropdown_object: template_dropdown_object,
    template_error: template_error
  });

  var isMergeableObject = function isMergeableObject(value) {
  	return isNonNullObject(value) && !isSpecial(value);
  };

  function isNonNullObject(value) {
  	return !!value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object';
  }

  function isSpecial(value) {
  	var stringValue = Object.prototype.toString.call(value);

  	return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value);
  }

  // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
  var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
  var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

  function isReactElement(value) {
  	return value.$$typeof === REACT_ELEMENT_TYPE;
  }

  function emptyTarget(val) {
  	return Array.isArray(val) ? [] : {};
  }

  function cloneUnlessOtherwiseSpecified(value, options) {
  	return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
  }

  function defaultArrayMerge(target, source, options) {
  	return target.concat(source).map(function (element) {
  		return cloneUnlessOtherwiseSpecified(element, options);
  	});
  }

  function mergeObject(target, source, options) {
  	var destination = {};
  	if (options.isMergeableObject(target)) {
  		Object.keys(target).forEach(function (key) {
  			destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
  		});
  	}
  	Object.keys(source).forEach(function (key) {
  		if (!options.isMergeableObject(source[key]) || !target[key]) {
  			destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
  		} else {
  			destination[key] = deepmerge(target[key], source[key], options);
  		}
  	});
  	return destination;
  }

  function deepmerge(target, source, options) {
  	options = options || {};
  	options.arrayMerge = options.arrayMerge || defaultArrayMerge;
  	options.isMergeableObject = options.isMergeableObject || isMergeableObject;

  	var sourceIsArray = Array.isArray(source);
  	var targetIsArray = Array.isArray(target);
  	var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

  	if (!sourceAndTargetTypesMatch) {
  		return cloneUnlessOtherwiseSpecified(source, options);
  	} else if (sourceIsArray) {
  		return options.arrayMerge(target, source, options);
  	} else {
  		return mergeObject(target, source, options);
  	}
  }

  deepmerge.all = function deepmergeAll(array, options) {
  	if (!Array.isArray(array)) {
  		throw new Error('first argument should be an array');
  	}

  	return array.reduce(function (prev, next) {
  		return deepmerge(prev, next, options);
  	}, {});
  };

  var deepmerge_1 = deepmerge;

  var default_options = {
    target: '',
    multiple: false,
    value_key: 'value',
    label_key: 'label'
  };

  function dropdown(js_options) {
    var self = $(this);
    var options = deepmerge_1(default_options, js_options);

    self.html(_.template(template_dropdown)(options));

    if (options.data) {
      render(options.data);
      // Set the default
      if (options.value) self.find('.selectpicker').val(options.value).selectpicker('refresh');
      // trigger 'load' event
      self.trigger({ type: 'load' });
    } else if (options.url) {
      render(['Loading...']);
      $.ajax(options.url).fail(function (xhr, status, message) {
        // load error template
        self.html(_.template(template_error)({ message: message }));
      }).done(function (response) {
        render(response);
        self.find('.selectpicker').selectpicker('refresh');
        self.trigger({ type: 'load' });
      });
    }

    function render(data) {
      options.data = data;
      if (options.key) {
        // urlfilter
        self.urlfilter({
          selector: 'select.urlfilter',
          target: options.target,
          event: 'change',
          remove: true
        });
      }
      // re-render dropdown template options with fetched data
      var template = _typeof(data[0]) == 'object' ? 'template_dropdown_object' : 'template_dropdown_options';
      self.find('.selectpicker').html(_.template(default_templates[template])(options)).selectpicker(options.options);
    }

    return this;
  }

  if (typeof jQuery != 'undefined') {
    jQuery.extend(jQuery.fn, {
      dropdown: dropdown
    });
  }

  var _event;
  try {
    new Event('click');
    _event = function _event(name, options) {
      // On Firefox, you needed to send the right event subclass. This is no longer a problem.
      // See https://developer.mozilla.org/en-US/docs/Web/Reference/Events for the list
      // if (name.match(/click$|^mouse|^menu$/)) return new MouseEvent(name, options)
      // else if (name.match(/^key/))            return new KeyboardEvent(name, options)
      // else if (name.match(/^focus|^blur$/))   return new FocusEvent(name, options)
      return new Event(name, options);
    };
  } catch (e) {
    // The old fashioned way, for IE
    _event = function _event(name, options) {
      var evt = document.createEvent('event');
      evt.initEvent(name, options.bubbles, options.cancelable);
      return evt;
    };
  }

  function dispatch(name, options) {
    return this.each(function () {
      this.dispatchEvent(_event(name, $.extend({
        bubbles: true,
        cancelable: true
      }, options)));
    });
  }

  if (typeof jQuery != 'undefined') {
    jQuery.extend(jQuery.fn, {
      dispatch: dispatch
    });
  }

  var template_ = "<div class=\"position-relative\"><div class=\"formhandler\"><div class=\"note\"></div><div class=\"formhandler-table-header d-flex justify-content-between mb-2\"><div class=\"d-flex flex-wrap\"><div class=\"edit\"></div><div class=\"add\"></div><div class=\"count\"></div><div class=\"page\"></div><div class=\"size\"></div></div><div class=\"d-flex\"><div class=\"filters\"></div><div class=\"export\"></div></div></div><div class=\"<%- (options.table == 'grid') ? 'table_grid' : 'table' %>\"></div></div><div class=\"loader pos-cc d-none\"><div class=\"fa fa-spinner fa-spin fa-3x fa-fw\"></div><span class=\"sr-only\">Loading...</span></div></div><div class=\"modal formhandler-table-modal\" id=\"fh-modal-<%- idcount %>\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"fh-label-<%- idcount %>\" aria-hidden=\"true\"><div class=\"modal-dialog modal-sm\" role=\"document\"><div class=\"modal-content\"><form class=\"formhandler-table-modal-form modal-body\"><label id=\"fh-label-<%- idcount %>\" for=\"formhandler-table-modal-value\">Value</label><p><input class=\"form-control\" name=\"filter_input\"></p><div><button type=\"button\" class=\"btn btn-sm btn-secondary mr-1\" data-dismiss=\"modal\">Cancel</button><button type=\"submit\" class=\"btn btn-sm btn-primary mr-1\">Apply filter</button><a class=\"btn btn-sm btn-danger remove-action urlfilter\" data-dismiss=\"modal\" data-target=\"#\" href=\"#\">Remove filter</a></div></form></div></div></div>";
  var template_table = "<%\n  var filtered_cols = args['_c'] && args['_c'].length != options.columns.length ?\n                      options.columns.filter(function(col) { return args['_c'].indexOf('-' + col.name) < 0 }) :\n                      options.columns\n  var cols = options.columns.length ? filtered_cols : meta.columns;\n  cols = cols.filter(function(col) { return col.hide !== true})\n  var form_id = idcount\n%> <table class=\"table table-sm table-striped\"><thead> <% _.each(cols, function(colinfo) {\n        col_defaults(colinfo, data)\n        var menu_item = false\n        var col_id = idcount++\n        var qsort = parse('?')\n        var isSorted = _.includes(args['_sort'], colinfo.name) ? {op: '', cls: 'table-primary'} : _.includes(args['_sort'], '-' + colinfo.name) ? {op: '-', cls: 'table-danger'} : {}\n      %> <th class=\"<%- isSorted.cls %>\" data-col=\"<%- colinfo.name %>\"><div class=\"dropdown\"><a href=\"#\" class=\"dropdown-toggle text-nowrap\" id=\"fh-dd-<%- col_id %>\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\"> <%- colinfo.title || colinfo.name %> </a><div class=\"dropdown-menu\" aria-labelledby=\"fh-dd-<%- col_id %>\"> <% _.each(colinfo.sort, function(title, op) { menu_item = true\n              qsort = qsort.update({_sort: args['_sort'] || []})\n              if (!_.isEmpty(isSorted))\n                qsort = qsort.update({_sort: [colinfo.name, '-' + colinfo.name]}, 'del')\n              var active = _.includes(args['_sort'], op + colinfo.name) %> <a class=\"dropdown-item urlfilter <%- active ? 'active': '' %>\" href=\"<%- qsort.update({_sort: [op + colinfo.name]}, active ? 'del': 'add').toString() %>\"> <%- title %> </a> <% }) %> <% if (menu_item) { %> <div class=\"dropdown-divider\"></div> <% menu_item = false } %> <% _.each(colinfo.filters, function(title, op) { menu_item = true %> <a class=\"dropdown-item <%= colinfo.name + op in args ? 'active' : '' %>\" href=\"#\" data-op=\"<%- op %>\" data-toggle=\"modal\" data-target=\"#fh-modal-<%- form_id %>\"> <%- title %> </a> <% }) %> <% if (menu_item) {\n              menu_item = false %> <div class=\"dropdown-divider\"></div> <% } %> <% if (colinfo.hideable) { %> <a class=\"dropdown-item urlfilter\" href=\"?_c=-<%- encodeURIComponent(colinfo.name) %>\" data-mode=\"add\">Hide</a> <% } %> </div></div></th> <% }) %> </thead><tbody> <% if (isAdd) { %> <tr class=\"new-row\"> <% _.each(cols, function(colinfo) {\n          if (!colinfo.template) { %> <td data-key=\"<%- colinfo.name %>\"> <% var isEditable = colinfo.editable === undefined ? true : colinfo.editable %> <%= _.template(templates['template_editable'])({isEditable: isEditable, val: undefined}) %> </td> <% } else { %> <td></td> <% } %> <% }) %> </tr> <% } %> <% if (options.rowTemplate) { %> <% _.each(data, function(row, rowIndex) { %> <%= typeof options.rowTemplate == 'function' ? options.rowTemplate({row: row, data: data, index: rowIndex}) : _.template(options.rowTemplate)({row: row, data: data, index: rowIndex}) %> <% }) %> <% } else {%> <% _.each(data, function(row, rowIndex) { %> <tr data-val=\"<%- JSON.stringify(row) %>\" data-row=\"<%- rowIndex %>\"> <% _.each(cols, function(colinfo) { %> <% var fmt = typeof(colinfo.format),\n            val = row[colinfo.name],\n            isEditable = colinfo.editable === undefined ? true : colinfo.editable,\n            disp = fmt == \"function\" ?\n              colinfo.format({name: colinfo.name, value: val, index: rowIndex, row: row, data:data }) :\n            fmt === \"string\" && colinfo.type === \"number\" ?\n              numeral(val).format(colinfo.format) :\n            fmt === \"string\" && colinfo.type === \"date\" ?\n              moment.utc(val).format(colinfo.format):\n              val,\n            col_link\n          %> <% if (!isEdit && colinfo.template) { %> <%= typeof colinfo.template == 'function' ?\n              colinfo.template({name: colinfo.name, value: val, format: disp, link: col_link, index: rowIndex, row: row, data: data}) :\n              _.template(colinfo.template)(({name: colinfo.name, value: val, format: disp, link: col_link, index: rowIndex, row: row, data: data})) %> <% } else if (!isEdit && 'link' in colinfo) { %> <% col_link = typeof colinfo.link == 'function' ?\n              colinfo.link({name: colinfo.name, value: val, format: disp, index: rowIndex, row: row, data: data}) :\n              (typeof colinfo.link == 'string' ?\n                _.template(colinfo.link)({name: colinfo.name, value: val, format: disp, index: rowIndex, row: row, data: data})\n                : colinfo.link)\n                %> <% if (col_link === false) { %> <td><%= disp %></td> <% } else if (col_link && col_link[0] == '?') { %> <td><a class=\"urlfilter\" href=\"<%- col_link %>\"><%= disp %></a></td> <% } else { %> <td><a href=\"<%- col_link %>\" target=\"_blank\"><%= disp %></a></td> <% } %> <% } else if (isEdit && isEditable) { %> <td data-key=\"<%- colinfo.name %>\"> <%= _.template(templates['template_editable'])({isEditable: isEditable, val: val}) %> </td> <% } else { %> <td><a class=\"urlfilter\" href=\"?<%- encodeURIComponent(colinfo.name) %>=<%- encodeURIComponent(val) %>&_offset=\"> <%= disp %> </a></td> <% } %> <% }) %> </tr> <% }) %> <% } %> </tbody></table>";
  var template_editable = "<% if (isEditable.input == 'select') { %> <select <% for (key in isEditable.attrs) { %> <%= key + '=\"' + isEditable.attrs[key] + '\"' %> <% } %> class=\"form-control form-control-sm\"><option value=\"\" disabled selected>-- select --</option> <% _.each(isEditable.options, function(item) { %> <option <%- val !== undefined && val === item ? 'selected': null %> value=\"<%- item %>\"> <%- item %> </option> <% }) %> </select> <% } else if (isEditable.input == 'radio') { %> <% _.each(isEditable.options, function(item) { %> <input type=\"radio\" <%- val !== undefined && val === item ? 'checked': null %> value=\"<%- item %>\" <% for (key in isEditable.attrs) { %> <%= key + '=\"' + isEditable.attrs[key] + '\"' %> <% } %> class=\"form-control form-control-sm\"> <%- item %> <br> <% }) %> <% } else { %> <input type=\"<%- isEditable.input || 'text' %>\" value=\"<%- val %>\" <% for (key in isEditable.attrs) { %> <%= key + '=\"' + isEditable.attrs[key] + '\"' %> <% } %> class=\"form-control form-control-sm\"> <% } %> <% if (isEditable.validationMessage) { %> <div class=\"invalid-feedback\"> <%- isEditable.validationMessage %> </div> <% } %>";
  var template_page = "<% var page = 1 + Math.floor(meta.offset / meta.limit),\n      last_page = 'count' in meta ? Math.floor((meta.count + meta.limit - 1) / meta.limit) : meta.rows < meta.limit ? page : null,\n      lo = Math.max(page - 2, 1),\n      hi = last_page !== null ? Math.min(last_page, page + 2) : page + 2 %> <ul class=\"pagination pagination-sm mr-2\"><li class=\"page-item <%- page <= 1 ? 'disabled' : '' %>\"><a class=\"page-link\" href=\"?_offset=<%- meta.offset - meta.limit %>\">Previous</a></li> <% if (lo > 1) { %> <li class=\"page-item\"><a class=\"page-link\" href=\"?_offset=\">1</a></li> <% if (lo > 2) { %> <li class=\"page-item disabled\"><a class=\"page-link\" href=\"#\">...</a></li> <% } %> <% } %> <% _.each(_.range(lo, hi + 1), function(pg) { %> <li class=\"page-item <%- pg == page ? 'active' : '' %>\"><a class=\"page-link\" href=\"?_offset=<%- meta.limit * (pg - 1) || '' %>\"> <%- pg %> </a></li> <% }) %> <% if ('count' in meta) { %> <% if (hi + 1 < last_page) { %> <li class=\"page-item disabled\"><a class=\"page-link\" href=\"#\">...</a></li> <% } %> <% if (hi < last_page || lo > hi) { %> <li class=\"page-item\"><a class=\"page-link\" href=\"?_offset=<%- meta.limit * (last_page - 1) %>\"> <%- last_page %> </a></li> <% } %> <% } %> <li class=\"page-item <%- (last_page === null) || (page < last_page) ? '' : 'disabled' %>\"><a class=\"page-link\" href=\"?_offset=<%- meta.offset + meta.limit %>\">Next</a></li></ul>";
  var template_size = "<% if (meta.limit) { %> <div class=\"btn-group btn-group-sm mr-2\" role=\"group\"><button id=\"formhandler-size-<%- idcount++ %>\" type=\"button\" class=\"btn btn-light btn-sm dropdown-toggle\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\"> <%- meta.limit %> rows</button><div class=\"dropdown-menu\" aria-labelledby=\"formhandler-size-<%- idcount %>\"> <% _.each(options.sizeValues, function(size) { %> <a class=\"dropdown-item <%- meta.limit == size ? 'active' : '' %> urlfilter\" href=\"?_limit=<%- size %>\"> <%- size %> </a> <% }) %> </div></div> <% } %>";
  var template_count = "<% if ('count' in meta) { %> <span class=\"btn btn-sm btn-light mr-2\"> <%- meta.count %> rows</span> <% } %>";
  var template_edit = "<button type=\"submit\" class=\"btn btn-success mr-2 btn-sm edit-btn\">Edit</button>";
  var template_add = "<button type=\"button\" class=\"btn btn-success mr-2 btn-sm add-btn\">Add</button>";
  var template_export = "<div class=\"btn-group btn-group-sm\" role=\"group\"><button id=\"formhandler-export-<%- idcount++ %>\" type=\"button\" class=\"btn btn-light btn-sm dropdown-toggle\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\">Export as</button><div class=\"dropdown-menu dropdown-menu-right\" aria-labelledby=\"formhandler-export-<%- idcount %>\"> <% _.each(options.exportFormats, function(label, key) { %> <a class=\"dropdown-item\" href=\"<%- parse(options.src).update(args).update({_format: key}) %>\"> <%- label %> </a> <% }) %> </div></div>";
  var template_filters = "<div class=\"p-1\"><%\n  var qparts = parse('?')\n  _.each(args['_c'], function(col_name) {\n    qparts.update({_c: col_name}, 'add')\n    var hide_col = col_name[0] == '-'\n    var display_name = hide_col ? col_name.slice(1) : col_name %> <a href=\"?_c=<%- encodeURIComponent(col_name) %>\" data-mode=\"del\" class=\"badge badge-pill <%- hide_col ? 'badge-dark' : 'badge-danger' %> urlfilter\" title=\"<%- hide_col ? 'Show' : 'Hide' %> column <%- display_name %>\"> <%- display_name %> </a> <% })\n  _.each(args, function(list_values, key) {\n    if (key.charAt(0) !== '_' && key !== 'c') {\n      _.each(args[key], function(col_name) {\n        var update = {}\n        update[key] = col_name\n        qparts.update(update, 'add') %> <a href=\"?<%- encodeURIComponent(key) %>=<%- encodeURIComponent(col_name) %>\" data-mode=\"del\" class=\"badge badge-pill badge-dark urlfilter\" title=\"Clear <%- key %> filter\"> <%- key %> = <%- col_name %> </a> <% })\n    }\n  })\n  qparts = qparts.toString()\n  if (qparts && qparts != '?') { %> <a href=\"?<%- qparts.slice(1) %>\" class=\"badge badge-pill badge-danger urlfilter\" data-mode=\"del\" title=\"Clear all filters\"></a> <% } %> </div>";
  var template_error$1 = "<div class=\"alert alert-warning alert-dismissible\" role=\"alert\"> <%- message %> <button type=\"button\" class=\"close\" data-dismiss=\"alert\" aria-label=\"Close\"><span aria-hidden=\"true\"></span></button></div>";
  var template_table_grid = "<%\n  var filtered_cols = args['_c'] && args['_c'].length != options.columns.length ?\n                      options.columns.filter(function(col) { return args['_c'].indexOf('-' + col.name) < 0 }) :\n                      options.columns\n  var cols = options.columns.length ? filtered_cols : meta.columns\n  var form_id = idcount, img\n  if (options.rowTemplate) {\n    _.each(data, function(row, rowIndex) { %> <%= typeof options.rowTemplate == 'function' ? options.rowTemplate({row: row, index: rowIndex, data: data}) : _.template(options.rowTemplate)({row: row, data: data, index: rowIndex}) %> <% })\n} else { %> <div class=\"formhandler-grid row\"> <% _.each(data, function(row, rowIndex) { %> <div class=\"col-sm-3 <%= options.classes || 'formhandler-grid-cell d-inline-block p-3 box-shadow' %>\"><div class=\"thumbnail\"> <% img = options.icon ? ((typeof(options.icon) == 'function' ? options.icon({row: row, data: data, index: rowIndex}) : options.icon)) : 'fa fa-home' %> <% if (img.indexOf('fa ') >= 0) { %> <i class=\"<%= img %>\"></i> <% } else { %> <img class=\"img img-responsive\" src=\"<%= img %>\"> <% } %> <div class=\"caption\"> <% _.each(cols, function(colinfo) {\n              var fmt = typeof(colinfo.format),\n                  val = row[colinfo.name],\n                  disp = (fmt == \"function\" ? colinfo.format({index: rowIndex, name: colinfo.name, value: val, row: row, data:data }) :\n                          fmt === \"string\" && colinfo.type === \"number\" ? numeral(val).format(colinfo.format) :\n                          fmt === \"string\" && colinfo.type === \"date\" ? moment.utc(val).format(colinfo.format) :\n                          val) %> <div><strong><%= colinfo.name %></strong>: <% if ('link' in colinfo) { %> <% var col_link = typeof colinfo.link == 'function' ?\n                      colinfo.link({row: row, value: val, index: rowIndex, name: colinfo.name, data: data, format: disp}) :\n                      _.template(colinfo.link)({row: row, value: val, index: rowIndex, name: colinfo.name, data: data, format: disp}) %> <% if (col_link === false) { %> <%= disp %> <% } else if (col_link && col_link[0] == '?') { %> <a class=\"urlfilter\" href=\"<%- col_link %>\"><%= disp %></a> <% } else { %> <a href=\"<%- col_link %>\" target=\"_blank\"><%= disp %></a> <% } %> <% } else { %> <a class=\"urlfilter\" href=\"?<%- encodeURIComponent(colinfo.name) %>=<%- encodeURIComponent(val) %>&_offset=\"> <%= disp %> </a> <% } %> </div> <% }) %> </div></div></div> <% }) %> </div> <% } %>";

  var default_templates$1 = /*#__PURE__*/Object.freeze({
    template_: template_,
    template_table: template_table,
    template_editable: template_editable,
    template_page: template_page,
    template_size: template_size,
    template_count: template_count,
    template_edit: template_edit,
    template_add: template_add,
    template_export: template_export,
    template_filters: template_filters,
    template_error: template_error$1,
    template_table_grid: template_table_grid
  });

  // Import HTML sections as variables using rollup-plugin-htmlparts.js.

  // Render components in this order. The empty component is the root component.
  var components = ['', 'table', 'edit', 'add', 'page', 'size', 'count', 'export', 'filters', 'error', 'table_grid'];
  var default_options$1 = {
    table: true,
    edit: false,
    add: false,
    page: true,
    pageSize: 100,
    size: true,
    sizeValues: [10, 20, 50, 100, 500, 1000],
    count: true,
    export: true,
    exportFormats: {
      xlsx: 'Excel',
      csv: 'CSV',
      json: 'JSON',
      html: 'HTML'
    },
    filters: true,
    onhashchange: true
  };
  var meta_headers = ['filters', 'ignored', 'excluded', 'sort', 'offset', 'limit', 'count'];

  var default_filters = {
    text: { '': 'Equals...', '!': 'Does not equal...', '~': 'Contains...', '!~': 'Does not contain...' },
    number: { '': 'Equals...', '!': 'Does not equal...', '<': 'Less than...', '>': 'Greater than...' },
    date: { '': 'Equals...', '!': 'Does not equal...', '<': 'Before...', '>': 'After...' }

    // Set default values for column specifications
    // function col_defaults(colinfo, data) {
  };function col_defaults(colinfo) {
    // Sort defaults
    if (!('sort' in colinfo) || colinfo.sort === true) colinfo.sort = { '': 'Sort ascending', '-': 'Sort descending' };else if (_typeof(colinfo.sort) != 'object') colinfo.sort = {};

    // Type defaults
    colinfo.type = colinfo.type || 'text';

    // Filters defaults
    if (!('filters' in colinfo) || colinfo.filters === true) colinfo.filters = default_filters[colinfo.type];

    // Hideable defaults
    if (!('hideable' in colinfo)) colinfo.hideable = true;

    // Hide defaults
    if (!('hide' in colinfo)) colinfo.hide = false;
  }

  function formhandler(js_options) {
    if (!js_options) js_options = {};

    this.each(function () {
      var $this = $(this);
      // Convert all .urlfilter classes into url filters that update location.hash
      $this.urlfilter({
        selector: '.urlfilter, .page-link',
        target: '#',
        remove: true // auto-remove empty values
      });

      // Pre-process options
      var options = $.extend({}, default_options$1, js_options, $this.data());

      if (!options.columns) options.columns = [];else if (typeof options.columns == 'string') options.columns = _.map(options.columns.split(/\s*,\s*/), function (col) {
        return { name: col };
      });

      // Compile all templates
      var template = {};
      _.each(components, function (name) {
        var tmpl = options[name ? name + 'Template' : 'template'] || default_templates$1['template_' + name] || 'NA';
        template[name] = _.template(tmpl);
      });

      function draw_table(data, args, meta) {
        // Add metadata
        meta.rows = data.length;
        meta.columns = data.length ? _.map(data[0], function (val, col) {
          return { name: col };
        }) : [];

        // If any column name is '*', show all columns
        var star_col = _.find(options.columns, function (o) {
          return o['name'] === '*';
        });
        if (star_col) {
          var action_header_cols = _.cloneDeep(meta.columns);
          _.map(options.columns, function (option_col) {
            var found = _.find(meta.columns, function (o) {
              return o['name'] === option_col.name;
            });
            if (!found && option_col.name !== '*') action_header_cols.push(option_col);
          });

          action_header_cols = _.map(action_header_cols, function (col) {
            var options_col = _.find(options.columns, function (o) {
              return o['name'] === col.name;
            });
            return options_col ? options_col : $.extend({}, star_col, col);
          });
        }

        options.columns = action_header_cols ? action_header_cols : options.columns;

        // Render all components into respective targets
        var template_data = {
          data: data,
          meta: meta,
          args: args,
          options: options,
          idcount: 0,
          parse: parse,
          col_defaults: col_defaults,
          isEdit: false,
          isAdd: false,
          templates: default_templates$1
          // Store template_data in $this
        };$this.data('formhandler', template_data);

        _.each(components, function (name) {
          render_template(name, template_data, options, $this, template);
        });
        if (options.add) addHandler($this, template_data, options, template);
        if (options.edit) editHandler($this, template_data, options, template);
      }

      function render() {
        var url_args = parse(location.hash.replace(/^#/, '')).searchList;
        url_args = namespace(url_args, options.name);
        // Create arguments passed to the FormHandler. Override with the user URL args
        var args = _.extend({
          c: options.columns.map(function (d) {
            return d.name;
          }),
          _limit: options.pageSize,
          _format: 'json',
          _meta: 'y'
        }, url_args);
        $('.loader', $this).removeClass('d-none');

        function done(data, status, xhr) {
          var meta = {};
          _.each(meta_headers, function (header) {
            var val = xhr ? xhr.getResponseHeader('Fh-Data-' + header) : null;
            if (val !== null) meta[header] = JSON.parse(val);
          });
          if (typeof options.transform == 'function') {
            var result = options.transform({ data: data, meta: meta, options: options, args: args }) || {};
            data = 'data' in result ? result.data : data;
            meta = 'meta' in result ? result.meta : meta;
          }

          // To support data-src that doesn't poin to formhandler url pattern
          if (_.isEmpty(meta) && options.page && options.size) {
            meta['offset'] = args._offset ? parseInt(args._offset) : 0;
            meta['limit'] = parseInt(args._limit);
            meta['count'] = data.length;
            data = datafilter(data, args);
          }

          draw_table(data, args, meta);
          $this.trigger({ type: 'load', formdata: data, meta: meta, args: args, options: options });
        }

        if (options.data && _typeof(options.data) == 'object') {
          options.edit = false;
          options.add = false;
          done(options.data);
        } else {
          $.ajax(options.src, {
            dataType: 'json',
            data: args,
            traditional: true
          }).done(done).always(function () {
            $('.loader', $this).addClass('d-none');
          }).fail(failHandler.bind(this, $this, template));
        }
      }

      modalHandler($this);

      actionHandler($this, options, template);

      // Re-render every time the URL changes
      if (options.onhashchange) $(window).on('hashchange', render);
      // Initialize
      render();
    });

    return this;
  }

  function modalHandler($this) {
    //  Handle modal dialog
    $this.on('shown.bs.modal', '.formhandler-table-modal', function (e) {
      var $el = $(e.relatedTarget);
      var template_data = $this.data('formhandler');
      var op = $el.data('op');
      var col = $el.closest('[data-col]').data('col');
      var val = '';
      // If there is a value, show it, and allow user to remove the filter
      if (template_data.args[col + op]) {
        val = template_data.args[col + op].join(',');
        $('.remove-action', this).attr('href', '?' + col + op + '=').show();
      } else $('.remove-action', this).hide();
      $('input', this).val(val).attr('name', col + op).focus();
      $('label', this).text($el.text());
    }).on('submit', 'form', function (e) {
      e.preventDefault();
      var filter = parse('?' + $(this).serialize()).searchKey;
      $(this).closest('.formhandler-table-modal').modal('hide');
      window.location.hash = '#' + parse(location.hash.replace(/^#/, '')).update(filter);
    });
  }

  function render_template(name, data, options, $this, template) {
    // Disable components if required. But root component '' is always displayed
    if (name && !options[name]) return;

    var target;
    // The root '' component is rendered into $this.
    if (!name) target = $this;else {
      // Rest are rendered into .<component-name> under $this

      if (options[name] == 'grid') name = 'table_grid';
      var selector = options[name + 'Target'] || '.' + name;
      target = $(selector, $this);
      // But if they don't exist, treat the selector as a global selecctor
      if (target.length == 0) target = $(selector);
    }
    target.html(template[name](data));
  }

  function addHandler($this, template_data, options, template) {

    $('.add button', $this).on('click', function () {
      var add_btn = $('.add button', $this);
      var edit_btn = $('.edit button', $this);
      if (add_btn.html().toLowerCase() == 'save') {
        add_btn.html('Add');
        edit_btn.prop('disabled', false);
        var columns_data = $('.new-row td[data-key]');

        $('.loader', $this).removeClass('d-none');
        var data = {};

        $.each(columns_data, function (key, column) {
          data[column.getAttribute('data-key')] = $(column).children().val();
        });
        // if no changes made to new empty celled row, rerender the table.
        if (!_.some(data)) {
          $('.loader', $this).addClass('d-none');
          template_data.isAdd = false;
          render_template('table', template_data, options, $this, template);
          return;
        }

        $.ajax(options.src, {
          method: 'POST',
          dataType: 'json',
          data: data
        }).done(function () {
          template_data.data.unshift(data);
          template_data.isAdd = false;
          render_template('table', template_data, options, $this, template);
          if (options.add.done) options.add.done();
        }).always(function () {
          $('.loader', $this).addClass('d-none');
        }).fail(failHandler.bind(this, $this, template));
      } else if (add_btn.html().toLowerCase() == 'add') {
        add_btn.html('Save');
        edit_btn.prop('disabled', true);
        template_data.isAdd = true;
        render_template('table', template_data, options, $this, template);
        add_edit_events($this, add_btn);
      }
    });
  }

  function editHandler($this, template_data, options, template) {
    $('.edit button', $this).on('click', function () {
      var edit_btn = $('.edit button', $this);
      var add_btn = $('.add button', $this);
      if (edit_btn.html().toLowerCase() == 'save') {
        var edited_rows = $('.edited-row');
        if (edited_rows.length > 0) $('.loader', $this).removeClass('d-none');

        var all_ajax = [];
        var allRowsValid = true;
        $.each(edited_rows, function (key, edited_row) {
          var data = JSON.parse(edited_row.getAttribute('data-val'));
          var rowIndex = edited_row.getAttribute('data-row');
          for (key in data) {
            // TODO: refactor to identify editable columns other than using data-key attrs on <td> tag
            $('td[data-key="' + remove_quotes(key) + '"] :input', edited_row).each(function () {
              if (this.checkValidity()) {
                $(this).removeClass('is-invalid');
                data[key] = template_data['data'][rowIndex][key] = $(this).val();
              } else {
                $(this).addClass('is-invalid');
                allRowsValid = false;
              }
            });
          }

          all_ajax.push($.ajax(options.src, {
            method: 'PUT',
            dataType: 'json',
            data: data
          }).fail(failHandler.bind(this, $this, template)).always(function () {
            $('.loader', $this).addClass('d-none');
            if (options.add.editFunction) options.add.editFunction();
          }));
        });

        if (!allRowsValid) return;
        $.when.apply($, all_ajax).then(function () {
          $('.loader', $this).addClass('d-none');
          edit_btn.html('Edit'); // TODO: remove hardcoding of name Edit
          add_btn.prop('disabled', false);
          if (options.edit.done) options.edit.done();
        });

        template_data.isEdit = false;
        render_template('table', template_data, options, $this, template);
      } else if (edit_btn.html().toLowerCase() == 'edit') {
        edit_btn.html('Save'); // TODO: remove hardcoding of name Save
        add_btn.prop('disabled', true);
        template_data.isEdit = true;
        render_template('table', template_data, options, $this, template);
        add_edit_events($this, edit_btn);
        $this.trigger({ type: 'editmode' });
      }
    });
  }

  function actionHandler($this, options, template) {
    var default_actions = {
      'delete': function _delete(arg) {
        return $.ajax(options.src, { method: 'DELETE', dataType: 'json', data: arg.row }).done(function () {
          $('tr[data-row="' + arg.index + '"]', $this).remove();
        });
      }
    };
    $this.on('click', '[data-action]', function () {
      var arg = {
        row: $(this).closest('[data-val]').data('val'),
        index: $(this).closest('[data-row]').data('row'),
        notify: notify.bind(this, $this, template)
      };
      var action = $(this).data('action');

      var method = options.actions && options.actions.filter(function (each_action) {
        return action in each_action;
      }).length > 0 ? options.actions.filter(function (each_action) {
        return action in each_action;
      })[0][action] : default_actions[action];

      var deferred = method(arg);
      if (deferred && deferred.always) {
        $('.loader', $this).removeClass('d-none');
        deferred.always(function () {
          $('.loader', $this).addClass('d-none');
        }).fail(failHandler.bind(this, $this, template));
      }
    });
  }

  function remove_quotes(str) {
    return str.toString().replace(/["']/g, '');
  }

  function notify($this, template, message) {
    var $note = $('.note', $this);
    if (!$note.length) $note = $('<div class="note"></div>').appendTo($this);
    $note.html(template['error']({ message: message }));
  }

  function failHandler($this, template, xhr, status, message) {
    var error = status + ': ' + message;
    if (xhr.readyState == 0) error += ' (cannot connect to server)';
    notify($this, template, error);
  }

  function add_edit_events($this, save_btn) {
    $('tbody :input', $this)
    // When the user types something, mark the row as changed
    .on('change', function () {
      $(this).parents('tr').addClass('edited-row');
    })
    // When the user presses Enter, click on the "Save" button
    .on('keypress', function (e) {
      if (e.keyCode == 13) {
        $(this).blur(); // Remove focus so that change / .edited-row is triggered
        save_btn.trigger('click');
      }
    })
    // Focus on the first element
    .eq(0).focus();
  }

  if (typeof jQuery != 'undefined') {
    jQuery.extend(jQuery.fn, {
      formhandler: formhandler
    });
  }

  var container_options$1 = {
    selector: '[data-toggle="highlight"]',
    target: '.highlight-target',
    mode: 'hover',
    classes: 'active'
  };

  function highlight(options) {
    this.each(function () {
      var settings = $.extend({}, container_options$1, options, this.dataset);
      var container = this;
      // Loop through all triggers in the container. This may include the container itself
      findall($(this), settings.selector).each(function () {
        var opts = $.extend({}, settings, this.dataset);
        var $this = $(this).off('.g1.highlight');
        var event = opts.mode == 'click' ? 'click.g1.highlight' : 'mouseenter.g1.highlight mouseleave.g1.highlight';
        $this.on(event, function () {
          // When the trigger is triggered, toggle the target classes and fire a highlight event
          var target = $(opts.target, container).toggleClass(opts.classes);
          $this.trigger({ type: 'highlight', target: target });
        });
      });
    });
    return this;
  }

  if (typeof jQuery != 'undefined') {
    jQuery.extend(jQuery.fn, {
      highlight: highlight
    });
  }

  function leaflet_topojson(json) {
    if (json.type === 'Topology') for (var key in json.objects) {
      L.GeoJSON.prototype.addData.call(this, topojson.feature(json, json.objects[key]));
    } else L.GeoJSON.prototype.addData.call(this, json);
  }

  if (typeof L !== 'undefined') L.TopoJSON = L.GeoJSON.extend({
    addData: leaflet_topojson
  });

  // data- attribute to store the last performed search
  var _lastsearch_attr = 'search-last';
  // data- attribute to store granular search results
  var _search_results = 'search-results';

  var container_options$2 = {
    selector: '[data-search]',
    hideClass: '',
    showClass: '',
    transform: 'strip',
    change: 'words'
  };

  function search(options) {
    var settings = $.extend({}, container_options$2, options, this.data());
    this.off('.g.search').on('keyup.g.search change.g.search', settings.selector, run_search).on('refresh.g.search', refresh).on('search.g.search', function (e) {
      refresh(e);
      run_search(e);
    });
    // If the container *IS* the trigger, run search
    this.filter(settings.selector).on('keyup.g.search change.g.search', run_search);
    return this;

    // Extract & transform search strings. Cache in input's dataset.search_results
    // Return the search strings.
    function refresh(e) {
      var opts = $.extend({}, settings, e.target.dataset);
      var search_text = opts.search == '@text' ? function (el) {
        return el.textContent;
      } : function (el) {
        return el.getAttribute(opts.search);
      };
      var transform = search.transforms[opts.transform];
      var result = $(opts.target).map(function () {
        var s = search_text(this);
        return { el: $(this), original: s, text: transform(s), show: true };
      }).get();
      $(e.target).data(_search_results, result).removeData(_lastsearch_attr);
      return result;
    }

    function run_search(e) {
      var opts = $.extend({}, settings, e.target.dataset);
      var $el = $(e.target);
      var out = {
        type: 'shown.g.search',
        searchText: $el.val()
      };
      out.search = search.changes[opts.change](search.transforms[opts.transform](out.searchText));
      var lastsearch = $el.data(_lastsearch_attr);
      if (lastsearch == out.search) return;
      $el.data(_lastsearch_attr, out.search);

      var hidecls = opts.hideClass,
          showcls = opts.showClass,
          re = new RegExp(out.search || '.*');
      out.results = $el.data(_search_results) || refresh(e);
      out.matches = out.results.length;
      out.results.forEach(function (cell) {
        var show = cell.text.match(re);
        if (show !== cell.show) {
          if (hidecls) cell.el[!show ? 'addClass' : 'removeClass'](hidecls);
          if (showcls) cell.el[show ? 'addClass' : 'removeClass'](showcls);
          cell.show = show;
        }
        if (!show) out.matches--;
      });
      $el.trigger(out);
    }
  }

  search.transforms = {
    strip: function strip(s) {
      return (s || '').toLowerCase().replace(/\s+/g, ' ').replace(/^ /, '').replace(/ $/, '');
    }
  };
  search.changes = {
    words: function words(s) {
      return s.replace(/\s+/g, '.*');
    }
  };

  if (typeof jQuery != 'undefined') {
    jQuery.extend(jQuery.fn, {
      search: search
    });
  }

  var _renderer = 'g1.template.render';
  var _compiled = 'g1.template.compiled';
  var _prev_created = 'g1.template.prev_created';

  function subtemplates($main) {
    // Takes a main template as a jQuery node with data-template-<name>="selector" attributes.
    // Return an object of {name: selector}
    return _.chain($main.data()).pickBy(function (val, key) {
      return key.match(/^template/);
    }).mapKeys(function (val, key) {
      return key.replace(/^template/, '').toLowerCase();
    }).value();
  }

  function template(data, options) {
    options = options || {};
    var self = this;
    var selector = options.selector || self.data('selector') || 'script[type="text/html"],template';

    // Pre-create the template rendering function
    // Store this in .data('template.function')
    findall(self, selector).each(function () {
      var $this = $(this);
      // If we want to dispose the last target, just dispose it.
      if (data === 'dispose') {
        var $oldtarget = $this.data(_prev_created);
        if ($oldtarget) $oldtarget.remove();
        return $this.trigger({
          type: 'template',
          templatedata: data,
          target: $oldtarget
        });
      }
      var renderer = $this.data(_renderer);
      // If the renderer is already present, just use it. Else compile it
      if (renderer) renderer(data, options);
      // If there are subtemplate dependencies, compile them
      else if (_.size(subtemplates($this))) dependent_templates($this, self, data, options);
        // If there aren't, then compile immediately.
        else make_template($this, data, options);
    });
    return this;
  }

  function dependent_templates(selector, self, data, options) {
    var uncompiled_selectors = _.pickBy(subtemplates(selector), function (sel) {
      return !$(sel).data(_compiled);
    });
    return Promise.all(_.map(uncompiled_selectors, function (sel) {
      return dependent_templates($(sel), self, data, options);
    })).then(function () {
      return Promise.all(_.union(_.map(uncompiled_selectors, function (sel) {
        return make_template($(sel), data, options);
      }), make_template(selector, data, options)));
    }).catch(function (error) {
      console.error(error);
    }); // eslint-disable-line no-console
  }

  function make_template($this, data, options) {
    // Compile templates. If the template has src="", load it and then compile it.
    // The result is in $this.data(_compiled) (via make_template_sync).
    var html = $this.html();
    // Contents of script are regular strings. Contents of template are escaped
    if (!$this.is('script')) html = _.unescape(html);

    var src = $this.attr('src');
    if (src) {
      // If the AJAX load succeeds, render the loaded template
      // Else render the contents, with an additional xhr variable
      return $.get(src).done(function (html) {
        make_template_sync($this, html, data, options);
      }).fail(function (xhr) {
        data.xhr = xhr;
        make_template_sync($this, html, data, options);
      });
    }
    // If no src= is specified, just render the contents
    else make_template_sync($this, html, data, options);
  }

  // Bind a template renderer to the node $this.data('template.render')
  // This renderer function accepts (data, options) and creates
  //    - runs the html template, parses the result, and create a target node
  //    - appends the target node after $this (clearing any previous target nodes)
  //    - stores the target node in $this.data('template.target')
  //    - triggers a template event (with .templatedata, .target)
  //    - returns the target node
  function make_template_sync($this, html, data, default_options) {
    var compiled_template = _.template(html);
    var $created;

    // $this.data(_compiled) has the compiled template. This adds sub-template
    // variables from data-template-* attributes.
    $this.data(_compiled, function (subtemplate_data) {
      subtemplate_data = _.extend({ $node: $this, $data: $this.data() }, _.mapValues(subtemplates($this), function (selector) {
        return $(selector).data(_compiled);
      }), subtemplate_data || {});
      return compiled_template(subtemplate_data);
    });

    function renderer(data, options) {
      html = $this.data(_compiled)(data);
      // Get options. DOM data-* over-rides JS options
      var append = $this.data('append') || (options ? options.append : default_options.append);
      var target = $this.data('target') || (options ? options.target : default_options.target);
      var engine = $this.data('engine') || (options ? options.engine : default_options.engine);
      if (!engine || typeof engine == 'string') engine = template.engines[engine] || template.engines['default'];
      // If we're appending the contents, just add the text
      if (append) {
        $created = $($.parseHTML(html.trim()));
        // If we're appending to a target node, just append to it.
        if (target) $(target).append($created);
        // If no target node, add BEFORE template. Future appends will be in sequence
        else $this.before($created);
      }
      // If we're not appending, replace the contents using the renderer
      else {
          // The engine must return the created nodes. See template.engines spec below
          $created = engine($this, target, html);
          // Store the created nodes for future reference. See template.engines spec below
          $this.data(_prev_created, $created);
        }
      // Trigger the template event. Use "templatedata" since ".data" is reserved
      $this.trigger({ type: 'template', templatedata: data, target: $created });
      return $created;
    }
    $this.data(_renderer, renderer);
    return $this.data('target') !== false ? renderer(data) : null;
  }

  // $.fn.template.engines is a registry of rendering engines. Each entry is a
  // function that accepts 3 parameters:
  //    $this: the <script> element
  //    target: the target selector or node to render into. May be undefined
  //    html: the HTML to render at the target (or around $this if target is missing)
  // It returns the created nodes as a jQuery object. This is used in 2 ways:
  //    - the template event.target attribute is this return value
  //    - $this.data(_prev_created) is set to this return value
  template.engines = {};

  // The default engine uses jQuery
  template.engines['default'] = template.engines['jquery'] = function ($this, target, html) {
    // Parse the template output and create a node collection
    // $.parseHTML ensures that "hello" is parsed as HTML, not a selector
    var $target = $($.parseHTML(html.trim()));
    // If target exists, replace the HTML. Otherwise, create new nodes before the template.
    if (target) $(target).html($target);else {
      // Remove any previous targets and re-create the output
      var $oldtarget = $this.data(_prev_created);
      if ($oldtarget) $oldtarget.remove();
      $this.before($target);
    }
    return $target;
  };

  /* globals morphdom */
  template.engines['vdom'] = function ($this, target, html) {
    // If no target is specified, use the previous target, if any
    target = target || $this.data(_prev_created);
    // If a target is specified, wrap the HTML with the target node.
    // For example, <div id="target">...</div> will wrap the HTML with
    // <div id="target"></div>
    var $target, tag_open, tag_close;
    if (target) {
      $target = $(target);
      var node = $target.get(0);
      tag_open = '<' + node.nodeName;
      $.each(node.attributes, function () {
        tag_open += ' ' + this.name + '=' + this.value;
      });
      tag_open += '>';
      tag_close = '</' + node.nodeName + '>';
    }
    // If a target is not specified, Create the target node before the template.
    // Wrap the HTML and the node with <div> to ensure that it's a single node.
    // Morphdom requires a single node.
    else {
        tag_open = '<div>';
        tag_close = '</div>';
        $target = $(tag_open + tag_close).insertBefore($this);
      }
    $target.each(function () {
      morphdom(this, tag_open + html + tag_close);
    });
    return $target;
  };

  if (typeof jQuery != 'undefined') {
    jQuery.extend(jQuery.fn, {
      template: template
    });
  }

  function array_eq(a, b) {
    return a && b && a.length === b.length && a.every(function (v, i) {
      return v === b[i];
    });
  }

  function urlchange() {
    var $self = this;
    // $self / this is typically a window, but could also be an iframe. Use its location
    var loc = $self.get(0).location;
    var oldurl,
        oldpath,
        oldhash = {};
    return $self.on('hashchange.urlchange', function () {
      var url = parse(loc.hash.replace(/^#/, ''));
      var change = {};
      var change_query = 0;
      // Parse keys in old & new URL hash. Trigger "#?<key>" if a key has changed
      for (var key in $.extend({}, url.searchList, oldhash)) {
        var vals = url.searchList[key] || [];
        var old = oldhash[key] || [];
        if (!array_eq(vals, old)) {
          var val = vals.length > 0 ? vals[0] : '';
          $self.trigger({ type: '#?' + key, hash: url, vals: vals, old: oldurl }, val);
          oldhash[key] = change[key] = vals;
          change_query += 1;
        }
      }
      // If the path has changed, trigger a "#/" event
      if (oldpath != url.pathname) {
        $self.trigger({ type: '#/', hash: url, old: oldurl }, url.pathname);
        change['/'] = oldpath = url.pathname;
      }
      // If any query has been changed, trigger a "#?" event with all info
      if (change_query) $self.trigger({ type: '#?', hash: url, change: change, old: oldurl }, url);
      // If any part of the hash has changed, trigger a "#" event with all info
      if (!$.isEmptyObject(change)) $self.trigger({ type: '#', hash: url, change: change, old: oldurl }, url);
      oldurl = url;
    }).trigger('hashchange');
  }

  if (typeof jQuery != 'undefined') {
    jQuery.extend(jQuery.fn, {
      urlchange: urlchange
    });
  }

  function translate(options) {
    options = options || {};
    var self = this;
    self.each(function () {
      var $this = $(this);
      var source = $this.attr('lang') || options.source || '';
      var target = $this.attr('lang-target') || options.target;
      if (!target) throw new Error('$.translate has no target');
      if (target == source) return;
      var nodes = [],
          original = [],
          q = [],
          node;
      var walk = document.createTreeWalker(this, NodeFilter.SHOW_TEXT, null, false);
      while (node = walk.nextNode()) {
        var text = node.textContent;
        var trimmed = $.trim(text);
        if (trimmed) {
          nodes.push(node);
          original.push(text);
          q.push(trimmed);
        }
      }
      var request = { q: q, source: source, target: target };
      $.ajax({
        url: $this.attr('lang-url') || options.url || 'translate',
        data: request,
        traditional: true
      }).done(function (response) {
        response.forEach(function (d, i) {
          d.node = nodes[i];
          d.node.textContent = original[i].replace(d.q, d.t);
        });
        $this.trigger({ type: 'translate', translate: response });
      }).fail(function (xhr, testStatus, error) {
        $this.trigger({ type: 'error', request: request, xhr: xhr });
        // eslint-disable-next-line no-console
        console.warn('$.translate: error', error);
      });
    });
    return this;
  }

  if (typeof jQuery != 'undefined') {
    jQuery.extend(jQuery.fn, {
      translate: translate
    });
  }

  exports.datafilter = datafilter;
  exports.fuzzysearch = fuzzysearch;
  exports.sanddance = sanddance;
  exports.scale = scale;
  exports.types = types;
  exports.url = url;
  exports.version = version;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
